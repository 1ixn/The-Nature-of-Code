<section xmlns="http://www.w3.org/1999/xhtml" data-type="chapter" id="_chapter_5_physics_libraries">
   <h1>Physics Libraries</h1>
   <blockquote data-type="epigraph">
      <p>“A library implies an act of faith/Which generations still in darkness hid/Sign in their night in witness of the dawn.”</p>
      <p data-type="attribution">— Victor Hugo</p>
   </blockquote>
   <p>Before we move on to anything else, let’s revisit some of the things we’ve done in the first four chapters. We have:<a data-primary="physics" data-secondary="open-source libraries for" data-type="indexterm"> </a>
      <a data-primary="physics libraries" data-type="indexterm"> </a>
   </p>
   <ol>
      <li>
         <p>Learned about concepts from the world of physics — What is a vector? What is a force? What is a wave? etc.</p>
      </li>
      <li>
         <p>Understood the math and algorithms behind such concepts.</p>
      </li>
      <li>
         <p>Implemented the algorithms in Processing with an object-oriented approach.</p>
      </li>
   </ol>
   <p>These activities have yielded a set of motion simulation examples, allowing us to creatively define the physics of the worlds we build (whether realistic or fantastical). Of course, we aren’t the first to try this. The world of computer graphics and programming is full of source code dedicated to simulation. Just try Googling “open-source physics engine” and you could spend the rest of your day pouring over rich and complex code. And so we must ask the question: If a code library will take care of physics simulation, why should we bother learning how to write any of the algorithms ourselves?</p>
   <p>Here is where the philosophy behind this book comes into play. While many of the libraries out there give us physics (and super awesome advanced physics at that) for free, there are significant reasons for learning the fundamentals from scratch before diving into libraries. First, without an understanding of vectors, forces, and trigonometry, we’d be completely lost just reading the documentation of a library. Second, even though a library may take care of the math for us, it won’t necessarily simplify our code. As we’ll see in a moment, there can be a great deal of overhead in simply understanding how a library works and what it expects from you code-wise. Finally, as wonderful as a physics engine might be, if you look deep down into your hearts, it’s likely that you seek to create worlds and visualizations that stretch the limits of imagination. A library is great, but it provides a limited set of features. It’s important to know both when to live within limitations in the pursuit of a Processing project and when those limits prove to be confining.</p>
   <p>This chapter is dedicated to examining two open-source physics libraries—Box2D and toxiclibs’ VerletPhysics engine. With each library, we’ll evaluate its pros and cons and look at reasons why you might choose one of these libraries for a given project.</p>
   <section data-type="sect1" id="chapter05_section1">
      <h1>What Is Box2D and When Is It Useful?</h1>
      <p>Box2D began as a set of physics tutorials written in C++ by Erin Catto for the Game Developer’s Conference in 2006. Over the last five years it has evolved into an rich and elaborate open-source physics engine. It’s been used for countless projects, most notably highly successful games such as the award-winning puzzle game Crayon Physics and the runaway mobile and tablet hit Angry Birds.</p>
      <p>One of the key things to realize about Box2D is that it is a true physics engine. Box2D knows nothing about computer graphics and the world of pixels; it is simply a library that takes in numbers and spits out more numbers. And what are those numbers? Meters, kilograms, seconds, etc. All of Box2D’s measurements and calculations are for real-world measurements—only its “world” is a two-dimensional plane with top, bottom, left, and right edges. You tell it things like: “The gravity of our world is 9.81 newtons per kilogram, and a circle with a radius of four meters and a mass of fifty kilograms is located ten meters above the world’s bottom.” Box2D will then tell you things like: “One second later, the rectangle is at five meters from the bottom; two seconds later, it is ten meters below,” etc. While this provides for an amazing and realistic physics engine, it also necessitates lots of complicated code in order to translate back and forth between the physics “world” (a key term in Box2D) and the world we want to draw on —the “pixel” world of Processing.<a data-primary="Box2D" data-secondary="overhead with" data-type="indexterm"> </a>
      </p>
      <p>So when is it worth it to have this additional overhead? If I just want to simulate a circle falling down a Processing window with gravity, do I really need to write all the extra Box2D code just to get that effect? Certainly, the answer is no. We saw how to do this rather easily in the first chapter of this book. Let’s consider another scenario. What if I want to have a hundred of those circles falling? And what if those circles aren’t circles at all, but irregularly shaped polygons? And what if I want these polygons to bounce off each other in a realistic manner when they collide?<a data-primary="collisions" data-type="indexterm"> </a>
         <a data-primary="physics" data-secondary="collisions" data-type="indexterm"> </a>
      </p>
      <p>You may have noticed that the first four chapters of this book, while covering motion and forces in detail, has skipped over a rather important aspect of physics simulation—<em>collisions</em>. Let’s pretend for a moment that you aren’t reading a chapter about libraries and that we decided right now to cover how to handle collisions in a particle system. We’d have to evaluate and learn two distinct algorithms that address these questions:<a data-primary="collisions" data-type="indexterm"> </a>
         <a data-primary="physics" data-secondary="collisions" data-type="indexterm"> </a>
      </p>
      <ol>
         <li>
            <p>How do I determine if two shapes are colliding (i.e. intersecting)?</p>
         </li>
         <li>
            <p>How do I determine the shapes’ velocity after the collision?</p>
         </li>
      </ol>
      <p>If we’re thinking about shapes like rectangles or circles, question #1 isn’t too tough. You’ve likely encountered this before. For example, we know two circles are intersecting if the distance between them is less than the sum of their radii.</p>
      <figure id="chapter05_figure1">
         <img alt="Figure 5.1" src="../images/chapter05/ch05_01.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>OK. Now that we know how to determine if two circles are colliding, how do we calculate their velocities after the collision? This is where we’re going to stop our discussion. Why, you ask? It’s not that understanding the math behind collisions isn’t important or valuable. (In fact, I’m including additional examples on the website related to collisions without a physics library.) The reason for stopping is that life is short (let this also be a reason for you to consider going outside and frolicking instead of programming altogether). We can’t expect to master every detail of physics simulation. And while we could continue this discussion for circles, it’s only going to lead us to wanting to work with rectangles. And strangely shaped polygons. And curved surfaces. And swinging pendulums colliding with springy springs. And and and and and.</p>
      <p>Working with collisions in our Processing sketch while still having time to spend with our friends and family—that’s the reason for this chapter. Erin Catto spent years developing solutions to these kinds of problems so you don’t need to engineer them yourselves, at least for now.</p>
      <p>In conclusion, if you find yourself describing an idea for a Processing sketch and the word “collisions” comes up, then it’s likely time to learn Box2D. (We’ll also encounter other words that might lead you down this path to Box2D, such as “joint,” “hinge,” “pulley,” “motor,” etc.)</p>
   </section>
   <section data-type="sect1" id="chapter05_section2">
      <h1>Getting Box2D in Processing</h1>
      <p>So, if Box2D is a physics engine that knows nothing about pixel-based computer graphics and is written in C++, how are we supposed to use it in Processing?</p>
      <p>The good news is that Box2D is such an amazing and useful library that everyone wants to use it—Flash, Javascript, Python, Ruby programmers. Oh, and Java programmers. There is something called JBox2D, a Java port of Box2D. And because Processing is built on top of Java, JBox2D can be used directly in Processing!<a data-primary="Box2D" data-secondary="JBox2D and" data-type="indexterm"> </a>
         <a data-primary="Java" data-type="indexterm"> </a>
         <a data-primary="JBox2D" data-type="indexterm"> </a>
         <a data-primary="Processing" data-secondary="JBox2D" data-type="indexterm"> </a>
      </p>
      <p>So here’s where we are so far.<a data-primary="Box2D" data-secondary="PBox2D helper class" data-type="indexterm"> </a>
         <a data-primary="PBox2D helper class" data-type="indexterm"> </a>
      </p>
      <ul>
         <li>
            <p>
               <a href="http://www.box2d.org/">Box2D site</a> for reference.</p>
         </li>
         <li>
            <p>
               <a href="http://www.jbox2d.org/">JBox2D site</a> for Processing compatibility.</p>
         </li>
      </ul>
      <p>This is all you need to get started writing Box2D code in Processing. However, as we are going to see in a moment, there are several pieces of functionality we’ll repeatedly need in our Processing code, and so it’s worth having one additional layer between our sketches and JBox2D. I’m calling this PBox2D—a Processing Box2D “helper” library included as part of this book’s code example downloads.<a data-primary="Box2D" data-secondary="PBox2D helper class" data-type="indexterm"> </a>
         <a data-primary="PBox2D helper class" data-type="indexterm"> </a>
      </p>
      <ul>
         <li>
            <p>
               <a href="http://github.com/shiffman/PBox2D">PBox2D GitHub repository</a>
            </p>
         </li>
      </ul>
      <p>It’s important to realize that PBox2D is not a Processing wrapper for all of Box2D. After all, Box2D is a thoughtfully organized and well-structured API and there’s no reason to take it apart and re-implement it. However, it’s useful to have a small set of functions that help you get your Box2D world set up, as well as help you figure out where to draw your Box2D shapes. And this is what PBox2D will provide.<a data-primary="Box2D" data-secondary="Fisica" data-type="indexterm"> </a>
         <a data-primary="Fisica" data-type="indexterm"> </a>
         <a data-primary="Marxer" data-secondary="Ricard" data-type="indexterm"> </a>
      </p>
      <p>I should also mention before we move forward that there are other Processing libraries that wrap Box2D for you. One I would recommend taking a look at is <a href="http://www.ricardmarxer.com/fisica/">Fisica</a> by Ricard Marxer.<a data-primary="Box2D" data-secondary="Fisica" data-type="indexterm"> </a>
         <a data-primary="Fisica" data-type="indexterm"> </a>
         <a data-primary="Marxer" data-secondary="Ricard" data-type="indexterm"> </a>
      </p>
   </section>
   <section data-type="sect1" id="chapter05_section3">
      <h1>Box2D Basics</h1>
      <p>Do not despair! We really are going to get to the code very soon, and in some ways we’ll blow our previous work out of the water. But before we’re ready to do that, it’s important to walk through the overall process of using Box2D in Processing. Let’s begin by writing a pseudocode generalization of all of our examples in Chapters 1 through 4.<a data-primary="Box2D" data-secondary="usage" data-type="indexterm"> </a>
      </p>
      <p>
         <strong>
            <em>SETUP:</em>
         </strong>
      </p>
      <ol>
         <li>
            <p>Create all the objects in our world.</p>
         </li>
      </ol>
      <p>
         <strong>
            <em>DRAW:</em>
         </strong>
      </p>
      <ol>
         <li>
            <p>Calculate all the forces in our world.</p>
         </li>
         <li>
            <p>Apply all the forces to our objects (F = M * A).</p>
         </li>
         <li>
            <p>Update the locations of all the objects based on their acceleration.</p>
         </li>
         <li>
            <p>Draw all of our objects.</p>
         </li>
      </ol>
      <p>Great. Let’s rewrite this pseudocode as it will appear in our Box2D examples.</p>
      <p>
         <strong>
            <em>SETUP:</em>
         </strong>
      </p>
      <ol>
         <li>
            <p>Create all the objects in our world.</p>
         </li>
      </ol>
      <p>
         <strong>
            <em>DRAW:</em>
         </strong>
      </p>
      <ol>
         <li>
            <p>Draw all of our objects.</p>
         </li>
      </ol>
      <p>This, of course, is the fantasy of Box2D. We’ve eliminated all of those painful steps of figuring out how the objects are moving according to velocity and acceleration. Box2D is going to take care of this for us! The good news is that this does accurately reflect the overall process. Let’s imagine Box2D as a magic box.</p>
      <p>In <strong function="">setup()</strong>, we’re going to say to Box2D: “Hello there. Here are all of the things I want in my world.” In <strong function="">draw()</strong>, we’re going to politely ask Box2D: “Oh, hello again. If it’s not too much trouble, I’d like to draw all of those things in my world. Could you tell me where they are?”</p>
      <p>The bad news: it’s not as simple as the above explanation would lead you to believe. For one, making the stuff that goes in the Box2D world involves wading through the documentation for how different kinds of shapes are built and configured. Second, we have to remember that we can’t tell Box2D anything about pixels, as it will simply get confused and fall apart. Before we tell Box2D what we want in our world, we have to convert our pixel units to Box2D “world” units. And the same is true when it comes time to draw our stuff. Box2D is going to tell us the location of the things in its world, which we then have to translate for the pixel world.</p>
      <ol>
         <li>
            <p>Create everything that lives in our pixel world.</p>
         </li>
         <li>
            <p>Translate the pixel world into the Box2D world.</p>
         </li>
      </ol>
      <ol>
         <li>
            <p>Ask Box2D where everything is.</p>
         </li>
         <li>
            <p>Translate Box2D’s answer into the pixel world.</p>
         </li>
         <li>
            <p>Draw everything.</p>
         </li>
      </ol>
      <p>Now that we understand that anything we create in our Processing sketch has to be placed into the Box2D world, let’s look at an overview of the elements that make up that world.<a data-primary="body (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="Box2D" data-secondary="core elements" data-type="indexterm"> </a>
         <a data-primary="fixture (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="joint (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="shape (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="Vec2 (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="vectors" data-secondary="Vec2 (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="World class (Box2D)" data-type="indexterm"> </a>
      </p>
      <ol>
         <li>
            <p>
               <strong>
                  <em>World</em>
               </strong>: Manages the physics simulation. It knows everything about the overall coordinate space and also stores lists of every element in the world (see 2-4 below).</p>
         </li>
         <li>
            <p>
               <strong>
                  <em>Body</em>
               </strong>: Serves as the primary element in the Box2D world. It has a location. It has a velocity. Sound familiar? The <strong>Body</strong> is essentially the class we’ve been writing on our own in our vectors and forces examples.</p>
         </li>
         <li>
            <p>
               <strong>
                  <em>Shape</em>
               </strong>: Keeps track of all the necessary collision geometry attached to a body.</p>
         </li>
         <li>
            <p>
               <strong>
                  <em>Fixture</em>
               </strong>: Attaches a shape to a body and sets properties such as density, friction, and restitution.</p>
         </li>
         <li>
            <p>
               <strong>
                  <em>Joint</em>
               </strong>: Acts as a connection between two bodies (or between one body and the world itself).</p>
         </li>
      </ol>
      <p>In the next four sections, we are going to walk through each of the above elements in detail, building several examples along the way. But first there is one other important element we should briefly discuss.<a data-primary="body (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="Box2D" data-secondary="core elements" data-type="indexterm"> </a>
         <a data-primary="fixture (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="joint (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="shape (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="Vec2 (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="vectors" data-secondary="Vec2 (Box2D element)" data-type="indexterm"> </a>
         <a data-primary="World class (Box2D)" data-type="indexterm"> </a>
      </p>
      <p>          6.   <strong>
            <em>Vec2</em>
         </strong>: Describes a vector in the Box2D world.</p>
      <p>And so here we are, arriving with trepidation at an unfortunate truth in the world of using physics libraries. Any physics simulation is going to involve the concept of a vector. This is the good part. After all, we just spent several chapters familiarizing ourselves with what it means to describe motion and forces with vectors. We don’t have to learn anything new conceptually.<a data-primary="Box2D" data-secondary="PVector vs." data-type="indexterm"> </a>
         <a data-primary="PVector class (Processing)" data-secondary="Box2D vs." data-type="indexterm"> </a>
      </p>
      <p>Now for the part that makes the single tear fall from my eye: we don’t get to use <strong klass="">PVector</strong>. It’s nice that Processing has <strong klass="">PVector</strong> for us, but anytime you use a physics library you will probably discover that the library includes its own vector implementation. This makes sense, after all; why should Box2D be expected to know about <strong klass="">PVector</strong>? And in many cases, the physics engine will want to implement a vector class in a specific way so that it is especially compatible with the rest of the library’s code. So while we don’t have to learn anything new conceptually, we do have to get used to some new naming conventions and syntax. Let’s quickly demonstrate a few of the basics in <strong klass="">Vec2</strong> as compared to those in <strong klass="">PVector</strong>.<a data-primary="Box2D" data-secondary="PVector vs." data-type="indexterm"> </a>
         <a data-primary="PVector class (Processing)" data-secondary="Box2D vs." data-type="indexterm"> </a>
      </p>
      <p>Let’s say we want to add two vectors together.<a data-primary="add() function (Vec2 class)" data-type="indexterm"> </a>
         <a data-primary="addLocal() function (Vec2)" data-type="indexterm"> </a>
         <a data-primary="Vec2 (Box2D element)" data-secondary="adding vectors with" data-type="indexterm"> </a>
      </p>
      <table class="code">
         <tbody>
            <tr>
               <th>PVector</th>
               <th>Vec2</th>
            </tr>
            <tr>
               <td>
                  <pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);

</pre>
               </td>
               <td>
                  <pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
a.addLocal(b);

</pre>
               </td>
            </tr>
            <tr>
               <td>
                  <pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);

</pre>
               </td>
               <td>
                  <pre>
Vec2 a = new Vec2(1,-1);
Vec2 b = new Vec2(3,4);
Vec2 c = a.add(b);

</pre>
               </td>
            </tr>
         </tbody>
      </table>
      <p>How about if we want to multiply and scale them?<a data-primary="Vec2 (Box2D element)" data-secondary="multiplying vectors with" data-type="indexterm"> </a>
         <a data-primary="Vec2 (Box2D element)" data-secondary="scaling vectors with" data-type="indexterm"> </a>
      </p>
      <table class="code">
         <tbody>
            <tr>
               <th>PVector</th>
               <th>Vec2</th>
            </tr>
            <tr>
               <td>
                  <pre>
PVector a = new PVector(1,-1);
float n = 5;
a.mult(n);

</pre>
               </td>
               <td>
                  <pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
a.mulLocal(n);

</pre>
               </td>
            </tr>
            <tr>
               <td>
                  <pre>
PVector a = new PVector(1,-1);
float n = 5;
PVector c = PVector.mult(a,n);

</pre>
               </td>
               <td>
                  <pre>
Vec2 a = new Vec2(1,-1);
float n = 5;
Vec2 c = a.mul(n);

</pre>
               </td>
            </tr>
         </tbody>
      </table>
      <p>Magnitude and normalize?<a data-primary="Vec2 (Box2D element)" data-secondary="manitude" data-tertiary="finding" data-type="indexterm"> </a>
         <a data-primary="Vec2 (Box2D element)" data-secondary="normalizing vectors" data-type="indexterm"> </a>
      </p>
      <table class="code">
         <tbody>
            <tr>
               <th>PVector</th>
               <th>Vec2</th>
            </tr>
            <tr>
               <td>
                  <pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();

</pre>
               </td>
               <td>
                  <pre>
Vec2 a = new Vec2(1,-1);
float m = a.length();
a.normalize();

</pre>
               </td>
            </tr>
         </tbody>
      </table>
      <p>As you can see, the concepts are the same, but the function names and the arguments are slightly different. For example, instead of static and non-static <strong function="">add()</strong> and <strong function="">mult()</strong>, if a <strong klass="">Vec2</strong> is altered, the word “local” is included in the function name—<strong function="">addLocal()</strong>, <strong function="">multLocal()</strong>.<a data-primary="JBox2D" data-secondary="full documentation for" data-type="indexterm"> </a>
      </p>
      <p>We’ll cover the basics of what you need to know here, but if you are looking for more, full documentation of <strong>Vec2</strong> can be found by downloading the <a href="http://code.google.com/p/jbox2d/">JBox2D source code</a>.</p>
   </section>
   <section data-type="sect1" id="chapter05_section4">
      <h1>Living in a Box2D World</h1>
      <p>The Box2D <strong>World</strong> object is in charge of everything. It manages the coordinate space of the world, all of the stuff that lives in the world, and decides when time moves forward in the world.</p>
      <p>In order to have Box2D as part of our Processing sketches, the <strong klass="">World</strong> is the very first thing that needs to be set up. Here is where PBox2D comes in handy and takes care of making the world for us.<a data-primary="PBox2D helper class" data-secondary="createWorld() function" data-type="indexterm"> </a>
         <a data-primary="World class (Box2D)" data-secondary="createWorld() function (PBox2D)" data-type="indexterm"> </a>
      </p>
      <pre>
PBox2D box2d;

void setup() {
  box2d = new PBox2D(this);
  box2d.createWorld();<span class="callout-bubble">  Initializes a Box2D world with default settings</span>
}
</pre>
      <p>When you call <strong function="">createWorld()</strong>, PBox2D will set up a default gravity for you (pointing down); however, you can always alter the gravity of your world by saying:<a data-primary="setGravity() function (World class)" data-type="indexterm"> </a>
      </p>
      <pre>
  box2d.setGravity(0, -10);
</pre>
      <p>It’s worth noting that gravity doesn’t have to be fixed, nor does it always have to point downwards; you can adjust the gravity vector while your program is running. Gravity can be turned off by setting it to a (0,0) vector.<a data-primary="setGravity() function (World class)" data-type="indexterm"> </a>
      </p>
      <p>So, what are those numbers 0 and -10? This should remind us of one of the most important details of using Box2D: the Box2D coordinate system is not your pixel coordinate system! Let’s look at how Box2D and a Processing window think differently of their worlds.<a data-primary="Box2D" data-secondary="coordinate system vs. Processing" data-type="indexterm"> </a>
         <a data-primary="coordinate systems" data-secondary="Box2D vs. Processing" data-type="indexterm"> </a>
         <a data-primary="Processing" data-secondary="coordinate systems vs. Box2D" data-type="indexterm"> </a>
      </p>
      <figure id="chapter05_figure2">
         <img alt="Figure 5.2" src="../images/chapter05/ch05_02.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>Notice how in Box2D <em>(0,0)</em> is in the center and <em>up</em> is the positive direction along the y-axis! Box2D’s coordinate system is just like that lovely old-fashioned Cartesian one with <em>(0,0)</em> in the center and <em>up</em> pointing in a positive direction. Processing, on the other hand, uses a traditional computer graphics coordinate system where <em>(0,0)</em> is in the top left corner and <em>down</em> is the positive direction along the y-axis. This is why if we want objects to fall down with gravity, we need to give Box2D a gravity force with a negative y-value.<a data-primary="Box2D" data-secondary="coordinate system vs. Processing" data-type="indexterm"> </a>
         <a data-primary="coordinate systems" data-secondary="Box2D vs. Processing" data-type="indexterm"> </a>
         <a data-primary="Processing" data-secondary="coordinate systems vs. Box2D" data-type="indexterm"> </a>
      </p>
      <pre>
Vec2 gravity = new Vec2(0, -10);
</pre>
      <p>Luckily for us, if we prefer to think in terms of pixel coordinates (which as Processing programmers, we are likely to do), PBox2D offers a series of helper functions that convert between pixel space and Box2D space. Before we move onto the next section and begin creating Box2D bodies, let’s take a look at how these helper functions work.<a data-primary="coordPixelsToWorld() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="PBox2D helper class" data-secondary="coordinate systems" data-tertiary="converting between" data-type="indexterm"> </a>
      </p>
      <p>Let’s say we want to tell Box2D where the mouse is in its world. We know the mouse is located at <strong class="var">(mouseX,mouseY)</strong> in Processing. To convert it, we say we want to convert a “coordinate” from “pixels” to “world”—<strong function="">coordPixelsToWorld()</strong>. Or:<a data-primary="coordPixelsToWorld() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="PBox2D helper class" data-secondary="coordinate systems" data-tertiary="converting between" data-type="indexterm"> </a>
      </p>
      <pre>
         <span class="callout-bubble">Convert mouseX,mouseY to</span>
         Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);<span class="callout-bubble">coordinate in Box2D world.</span>
</pre>
      <p>What if we had a Box2D world coordinate and wanted to translate it to our pixel space?</p>
      <pre>
         Vec2 worldPos = new Vec2(-10,25);<span class="callout-bubble">To demonstrate, let’s just make up a world position.</span>

<span class="callout-bubble">Convert to pixel space.</span>
         <span class="callout-bubble">This is necessary because ultimately we</span>
         Vec2 pixelPos = box2d.coordWorldToPixels(worldPos);<span class="callout-bubble">are going to want to draw the elements in our window.</span>
ellipse(pixelPos.x, pixelPos.y,16,16);
</pre>
      <p>PBox2D has a set of functions to take care of translating back and forth between the Box2D world and pixels. It’s probably easier to learn about all of these functions during the course of actually implementing our examples, but let’s quickly look over the list of the possibilities.<a data-primary="coordWorldToPixels() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="scalarPixelsToWorld() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="scalarWorldToPixels() function (PBox2D)" data-type="indexterm"> </a>
      </p>
      <table class="code">
         <tbody>
            <tr>
               <th>Task</th>
               <th>Function</th>
            </tr>
            <tr>
               <td>Convert location from World to Pixels</td>
               <td>
                  <pre>
Vec2 coordWorldToPixels(Vec2 world)
</pre>
               </td>
            </tr>
            <tr>
               <td>Convert location from World to Pixels</td>
               <td>
                  <pre>
Vec2 coordWorldToPixels(float worldX, float worldY)
</pre>
               </td>
            </tr>
            <tr>
               <td>Convert location from Pixels to World</td>
               <td>
                  <pre>
Vec2 coordPixelsToWorld(Vec2 screen)
</pre>
               </td>
            </tr>
            <tr>
               <td>Convert location from Pixels to World</td>
               <td>
                  <pre>
Vec2 coordPixelsToWorld(float pixelX, float pixelY)
</pre>
               </td>
            </tr>
            <tr>
               <td>Scale a dimension (such as height, width, or radius) from Pixels to World</td>
               <td>
                  <pre>
float scalarPixelsToWorld(float val)
</pre>
               </td>
            </tr>
            <tr>
               <td>Scale a dimension from World to Pixels</td>
               <td>
                  <pre>
float scalarWorldToPixels(float val)
</pre>
               </td>
            </tr>
         </tbody>
      </table>
      <p>There are also additional functions that allow you to pass or receive a <strong klass="">PVector</strong> when translating back and forth, but since we are only working with Box2D in the examples in this chapter, it’s easiest to stick with the <strong klass="">Vec2</strong> class for all vectors.<a data-primary="coordWorldToPixels() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="scalarPixelsToWorld() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="scalarWorldToPixels() function (PBox2D)" data-type="indexterm"> </a>
      </p>
      <p>Once the world is initialized, we are ready to actually put stuff in the world—Box2D bodies.</p>
   </section>
   <section data-type="sect1" id="chapter05_section5">
      <h1>Building a Box2D Body</h1>
      <p>A Box2D body is the primary element in the Box2D world. It’s the equivalent to the <strong klass="">Mover</strong> class we built on our own in previous chapters—the thing that moves around the space and experiences forces. It can also be static (meaning fixed and not moving). It’s important to note, however, that a body has no geometry; it isn’t anything physical. Rather, bodies have Box2D shapes attached to them. (This way, a body can be a single rectangle or a rectangle attached to a circle, etc.) We’ll look at shapes in a moment; first, let’s build a body.<a data-primary="body (Box2D element)" data-secondary="building" data-type="indexterm"> </a>
      </p>
      <section data-type="sect2" id="_step_1_define_a_body">
         <h2>Step 1: Define a body.</h2>
         <p>The first thing we have to do is create a “body definition.” This will let us define the properties of the body we intend to make. This may seem a bit awkward at first, but it’s how Box2D is structured. Anytime you want to make a “thing,” you have to make a “thing definition” first. This will hold true for bodies, shapes, and joints.<a data-primary="body (Box2D element)" data-secondary="BodyDef type" data-type="indexterm"> </a>
            <a data-primary="BodyDef type (body element)" data-type="indexterm"> </a>
         </p>
         <pre>
            BodyDef bd = new BodyDef();<span class="callout-bubble">Make a body definition before making a Body.</span>
</pre>
      </section>
      <section data-type="sect2" id="_step_2_configure_the_body_definition">
         <h2>Step 2: Configure the body definition.</h2>
         <p>The body definition is where we can set specific properties or attributes of the body we intend to make. One attribute of a body, for example, is its starting location. Let’s say we want to position the body in the center of the Processing window.<a data-primary="BodyDef type (body element)" data-secondary="configuring" data-type="indexterm"> </a>
         </p>
         <pre>
            Vec2 center = new Vec2(width/2,height/2);<span class="callout-bubble">A Vec2 in the center of the Processing window</span>
</pre>
         <p>Danger, danger! I’m not going to address this with every single example, but it’s important to at least point out the perilous path we are taking with the above line of code. Remember, if we are going to tell Box2D where we want the body to start, we must give Box2D a world coordinate! Yes, we want to think of its location in terms of pixels, but Box2D doesn’t care. And so before we pass that position to the body definition, we must make sure to use one of our helper conversion functions.<a data-primary="body (Box2D element)" data-secondary="types of" data-type="indexterm"> </a>
            <a data-primary="dynamic (body type)" data-type="indexterm"> </a>
            <a data-primary="kinematic (body type)" data-type="indexterm"> </a>
            <a data-primary="static (body type)" data-type="indexterm"> </a>
         </p>
         <pre>
            <span class="callout-bubble">A Vec2 in the center of the</span>
            Vec2 center = box2d.coordPixelsToWorld(width/2,height/2));<span class="callout-bubble">Processing window converted to Box2D World coordinates!</span>
bd.position.set(center);<span class="callout-bubble">Setting the position attribute of the Box2D body definition</span>
</pre>
         <p>The body definition must also specify the “type” of body we want to make. There are three possibilities:<a data-primary="body (Box2D element)" data-secondary="types of" data-type="indexterm"> </a>
            <a data-primary="dynamic (body type)" data-type="indexterm"> </a>
            <a data-primary="kinematic (body type)" data-type="indexterm"> </a>
            <a data-primary="static (body type)" data-type="indexterm"> </a>
         </p>
         <ul>
            <li>
               <p>
                  <strong>
                     <em>Dynamic.</em>
                  </strong> This is what we will use most often—a “fully simulated” body. A dynamic body moves around the world, collides with other bodies, and responds to the forces in its environment.</p>
            </li>
            <li>
               <p>
                  <strong>
                     <em>Static.</em>
                  </strong> A static body is one that cannot move (as if it had an infinite mass). We’ll use static bodies for fixed platforms and boundaries.</p>
            </li>
            <li>
               <p>
                  <strong>
                     <em>Kinematic.</em>
                  </strong> A kinematic body can be moved manually by setting its velocity directly. If you have a user-controlled object in your world, you can use a kinematic body. Note that kinematic bodies collide only with dynamic bodies and not with other static or kinematic ones.</p>
            </li>
         </ul>
         <p>There are several other properties you can set in the body definition. For example, if you want your body to have a fixed rotation (i.e. never rotate), you can say:</p>
         <pre>
bd.fixedRotation = true;
</pre>
         <p>You can also set a value for linear or angular damping, so that the object continuously slows as if there is friction.<a data-primary="body (Box2D element)" data-secondary="bullet setting for" data-type="indexterm"> </a>
         </p>
         <pre>
bd.linearDamping = 0.8;
bd.angularDamping = 0.9;
</pre>
         <p>In addition, fast-moving objects in Box2D should be set as bullets. This tells the Box2D engine that the object may move very quickly and to check its collisions more carefully so that it doesn’t accidentally jump over another body.<a data-primary="body (Box2D element)" data-secondary="bullet setting for" data-type="indexterm"> </a>
         </p>
         <pre>
bd.bullet = true;
</pre>
      </section>
      <section data-type="sect2" id="_step_3_create_the_body">
         <h2>Step 3: Create the body.</h2>
         <p>Once we’re done with the definition (<strong klass="">BodyDef</strong>), we can create the <strong klass="">Body</strong> object itself. PBox2D provides a helper function for this—<strong function="">createBody</strong>().<a data-primary="body (Box2D element)" data-secondary="object" data-tertiary="creating" data-type="indexterm"> </a>
            <a data-primary="createBody() function (PBox2D)" data-type="indexterm"> </a>
         </p>
         <pre>
            <span class="callout-bubble">The Body object is created by passing in the Body</span>
            <span class="callout-bubble">Definition. (This allows for making multiple bodies from</span>
            Body body = box2d.createBody(bd);<span class="callout-bubble">one definition.)</span>
</pre>
      </section>
      <section data-type="sect2" id="_step_4_set_any_other_conditions_for_the_body_s_starting_state">
         <h2>Step 4: Set any other conditions for the body’s starting state.</h2>
         <p>Finally, though not required, if you want to set any other initial conditions for the body, such as linear or angular velocity, you can do so with the newly created <strong klass="">Body</strong> object.<a data-primary="body (Box2D element)" data-secondary="initial settings for" data-type="indexterm"> </a>
         </p>
         <pre>
            body.setLinearVelocity(new Vec2(0,3));<span class="callout-bubble">Setting an arbitrary initial velocity</span>
body.setAngularVelocity(1.2);<span class="callout-bubble">Setting an arbitrary initial angular velocity</span>
</pre>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section6">
      <h1>Three’s Company: Bodies and Shapes and Fixtures</h1>
      <p>A body on its own doesn’t physically exist in the world. It’s like a soul with no human form to inhabit. For a body to have mass, we must first define a shape and attach that shape to the body with something known as a fixture.</p>
      <p>The job of the Box2D <strong klass="">Shape</strong> class is to keep track of all the necessary collision geometry attached to a body. A shape also has several important properties that affect the body’s motion. There is density, which ultimately determines that body’s mass. Shapes also have <em>friction</em> and <em>restitution</em> (“bounciness”) which will be defined through a fixture. One of the nice things about Box2D’s methodology, which separates the concepts of bodies and shapes into two separate objects, is that you can attach multiple shapes to a single body in order to create more complex forms. We’ll see this in a future example.<a data-primary="Shape (Box2D element)" data-secondary="friction attribute" data-type="indexterm"> </a>
         <a data-primary="Shape (Box2D element)" data-secondary="restitution attribute" data-type="indexterm"> </a>
      </p>
      <p>To create a shape, we need to first decide what kind of shape we want to make. For most non-circular shapes, a <strong>PolygonShape</strong> object will work just fine. For example, let’s look at how we define a rectangle.</p>
      <section data-type="sect2" id="_step_1_define_a_shape">
         <h2>Step 1: Define a shape.</h2>
         <pre>
            PolygonShape ps = new PolygonShape();<span class="callout-bubble">Define the shape: a polygon.</span>
</pre>
         <p>Next up, we have to define the width and height of the rectangle. Let’s say we want our rectangle to be 150×100 pixels. Remember, pixel units are no good for Box2D shapes! So we have to use our helper functions to convert them first.<a data-primary="Shape (Box2D element)" data-secondary="defining" data-type="indexterm"> </a>
         </p>
         <pre>
            float box2Dw = box2d.scalarPixelsToWorld(150);<span class="callout-bubble">Scale dimensions from pixels to Box2D world.</span>
float box2Dh = box2d.scalarPixelsToWorld(100);


ps.setAsBox(box2Dw, box2Dh);<span class="callout-bubble">Use setAsBox() function to define shape as a rectangle.</span>
</pre>
      </section>
      <section data-type="sect2" id="_step_2_create_a_fixture">
         <h2>Step 2: Create a fixture.</h2>
         <p>The shape and body are made as two separate entities. In order to attach a shape to a body, we must make a fixture. A fixture is created, just as with the body, via a fixture definition (i.e. <strong klass="">FixtureDef</strong> class) and assigned a shape.<a data-primary="fixture (Box2D element)" data-secondary="creating" data-type="indexterm"> </a>
         </p>
         <pre>
FixtureDef fd = new FixtureDef();
fd.shape = ps;<span class="callout-bubble">The fixture is assigned the PolygonShape we just made.</span>
</pre>
         <p>Once we have the fixture definition, we can set parameters that affect the physics for the shape being attached.</p>
         <pre>
            <span class="callout-bubble">The coefficient of friction for the</span>
            fd.friction = 0.3;<span class="callout-bubble">shape, typically between 0 and 1</span>
<span class="callout-bubble">The Shape’s restitution (i.e. elasticity),</span>
            fd.restitution = 0.5;<span class="callout-bubble">typically between 0 and 1</span>
<span class="callout-bubble">The Shape’s density, measured in</span>
            fd.density = 1.0;<span class="callout-bubble">kilograms per meter squared</span>
</pre>
      </section>
      <section data-type="sect2" id="_step_3_attach_the_shape_to_the_body_with_the_fixture">
         <h2>Step 3: Attach the shape to the body with the fixture.</h2>
         <p>Once the fixture is defined, all we have left to do is attach the shape to the body with the fixture by calling the <strong function="">createFixture()</strong> function.<a data-primary="body (Box2D element)" data-secondary="attaching fixture element to" data-type="indexterm"> </a>
            <a data-primary="createFixture() function (PBox2D)" data-type="indexterm"> </a>
            <a data-primary="fixture (Box2D element)" data-secondary="attaching to body element" data-type="indexterm"> </a>
         </p>
         <pre>
            body.createFixture(fd);<span class="callout-bubble">Creates the Fixture and attaches the Shape to the Body object</span>
</pre>
         <p>I should note that Step 2 can be skipped if you do not need to set the physics properties. (Box2D will use default values.) You can create a fixture and attach the shape all in one step by saying:</p>
         <pre>
            body.createFixture(ps,1);<span class="callout-bubble">Creates the Fixture and attaches the Shape with a density of 1</span>
</pre>
         <p>While most of our examples will take care of attaching shapes only once when the body is first built, this is not a limitation of Box2D. Box2D allows for shapes to be created and destroyed on the fly.</p>
         <p>Before we put any of this code we’ve been writing into a Processing sketch, let’s review all the steps we took to construct a Body.</p>
         <ol>
            <li>
               <p>Define a body using a <strong>BodyDef</strong> object (set any properties, such as location).</p>
            </li>
            <li>
               <p>Create the <strong>Body</strong> object from the body definition.</p>
            </li>
            <li>
               <p>Define a <strong>Shape</strong> object using <strong>PolygonShape</strong>, <strong>CircleShape</strong>, or any other shape class.</p>
            </li>
            <li>
               <p>Define a fixture using <strong>FixtureDef</strong> and assign the fixture a shape (set any properties, such as friction, density, and restitution).</p>
            </li>
            <li>
               <p>Attach the shape to the body.</p>
            </li>
         </ol>
         <pre>
            BodyDef bd = new BodyDef();<span class="callout-bubble">Step 1. Define the body.</span>
bd.position.set(box2d.coordPixelsToWorld(width/2,height/2));

Body body = box2d.createBody(bd);<span class="callout-bubble">Step 2. Create the body.</span>

PolygonShape ps = new PolygonShape();<span class="callout-bubble">Step 3. Define the shape.</span>
float w = box2d.scalarPixelsToWorld(150);
float h = box2d.scalarPixelsToWorld(100);
ps.setAsBox(w, h);

FixtureDef fd = new FixtureDef();<span class="callout-bubble">Step 4. Define the fixture.</span>
fd.shape = ps;
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

body.createFixture(fd);<span class="callout-bubble">Step 5. Attach the shape to the body with the Fixture.</span>
</pre>
         <aside data-type="sidebar" class="exercise">
            
            <p>Knowing what you know about Box2D so far, fill in the blank in the code below that demonstrates how to make a circular shape in Box2D.</p>
            <pre>
CircleShape cs = new CircleShape();
float radius = 10;
cs.m_radius = ____________________;
FixtureDef fd = new FixtureDef();
fd.shape = cs;
fd.density = 1;
fd.friction = 0.1;
fd.restitution = 0.3;

body.createFixture(fd);
</pre>
         </aside>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section7">
      <h1>Box2D and Processing: Reunited and It Feels So Good</h1>
      <p>Once a body is made, it lives in the Box2D physics world. Box2D will always know it’s there, check it for collisions, move it appropriately according to the forces, etc. It’ll do all that for you without you having to lift a finger! What it won’t do, however, is display the body for you. This is a good thing. This is your time to shine. When working with Box2D, what we’re essentially saying is, “I want to be the designer of my world, and I want you, Box2D, to compute all the physics.”<a data-primary="body lists" data-secondary="maintaining in Processing" data-type="indexterm"> </a>
         <a data-primary="getBodyList() function (World class)" data-type="indexterm"> </a>
         <a data-primary="Processing" data-secondary="body lists" data-tertiary="maintaining" data-type="indexterm"> </a>
         <a data-primary="World class (Box2D)" data-secondary="getBodyList() function" data-type="indexterm"> </a>
      </p>
      <p>Now, Box2D will keep a list of all the bodies that exist in the world. This can be accessed by calling the World object’s <strong function="">getBodyList()</strong> function. Nevertheless, what I’m going to demonstrate here is a technique for keeping your own body lists. Yes, this may be a bit redundant and we perhaps sacrifice a bit of efficiency. But we more than make up for that with ease of use. This methodology will allow us to program like we’re used to in Processing, and we can easily keep track of which bodies are which and render them appropriately. Let’s consider the structure of the following Processing sketch:<a data-primary="body lists" data-secondary="maintaining in Processing" data-type="indexterm"> </a>
         <a data-primary="getBodyList() function (World class)" data-type="indexterm"> </a>
         <a data-primary="Processing" data-secondary="body lists" data-tertiary="maintaining" data-type="indexterm"> </a>
         <a data-primary="World class (Box2D)" data-secondary="getBodyList() function" data-type="indexterm"> </a>
      </p>
      <figure id="chapter05_figure3">
         <img alt="Figure 5.3" src="../images/chapter05/ch05_03.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>This looks like any ol’ Processing sketch. We have a main tab called “Boxes” and a “Boundary” and a “Box” tab. Let’s think about the Box tab for a moment. The Box tab is where we will write a simple class to describe a <strong>Box</strong> object, a rectangular body in our world.</p>
      <pre>
class Box  {

  float x,y;<span class="callout-bubble">  Our Box object has an x,y location and a width and a height.</span>
  float w,h;


  Box(float x_, float y_) {
    x = x_;<span class="callout-bubble">    The location is initalized in the constructor via arguments</span>
    y = y_;

    w = 16;
    h = 16;
  }

  void display() {
    fill(175);<span class="callout-bubble">    We draw the Box object using Processing’s rect() function.</span>
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }
}
</pre>
      <p>Let’s write a main tab that creates a new <strong>Box</strong> whenever the mouse is pressed and stores all the <strong>Box</strong> objects in an <strong>ArrayList</strong>. (This is very similar to our approach in the particle system examples from Chapter 4.)</p>
      <figure class="screenshot">
         <img alt="ch05 ex01" src="../images/chapter05/ch05_ex01.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e1553" data-type="example">
         <h5>A comfortable and cozy Processing sketch that needs a little Box2D</h5>
         <pre>
            ArrayList&lt;Box&gt; boxes;<span class="callout-bubble">A list to store all Box objects</span>

void setup() {
  size(400,300);
  boxes = new ArrayList&lt;Box&gt;();
}

void draw() {
  background(255);

  if (mousePressed) {<span class="callout-bubble">  When the mouse is pressed, add a new Box object.</span>
    Box p = new Box(mouseX,mouseY);
    boxes.add(p);
  }


  for (Box b: boxes) {<span class="callout-bubble">  Display all the Box objects.</span>
    b.display();
  }

}
</pre>
      </div>
      
      <p>Now, here’s our assignment. Take the above example verbatim, but instead of drawing fixed boxes on the screen, draw boxes that experience physics (via Box2D) as soon as they appear.</p>
      <p>We’ll need two major steps to accomplish our goal.</p>
      <section data-type="sect2" id="_step_1_add_box2d_to_our_main_program_i_e_setup_and_draw">
         <h2>Step 1: Add Box2D to our main program (i.e. setup() and draw()).</h2>
         <p>This part is not too tough. We saw this already in our discussion of building a Box2D world. This is taken care of for us by the PBox2D helper class. We can create a PBox2D object and initialize it in <strong function="">setup()</strong>.</p>
         <pre>
PBox2D box2d;

void setup() {
  box2d = new PBox2D(this);<span class="callout-bubble">  Initialize and create the Box2D world.</span>
  box2d.createWorld();

}
</pre>
         <p>Then in <strong function="">draw()</strong>, we need to make sure we call one very important function: <strong function="">step()</strong>. Without this function, nothing would ever happen! <strong function="">step()</strong> advances the Box2D world a step further in time. Internally, Box2D sweeps through and looks at all of the Bodies and figures out what to do with them. Just calling <strong function="">step()</strong> on its own moves the Box2D world forward with default settings; however, it is customizable (and this is documented in the PBox2D source).<a data-primary="step() function (Box2D)" data-type="indexterm"> </a>
         </p>
         <pre>
void draw() {
  box2d.step();<span class="callout-bubble">  We must always step through time!</span>
}
</pre>
      </section>
      <section data-type="sect2" id="_step_2_link_every_processing_box_object_with_a_box2d_body_object">
         <h2>Step 2: Link every Processing Box object with a Box2D Body object.</h2>
         <p>As of this moment, the <strong>Box</strong> class includes variables for location and width and height. What we now want to say is:</p>
         <p>“I hereby relinquish the command of this object’s position to Box2D. I no longer need to keep track of anything related to location, velocity, and acceleration. Instead, I only need to keep track of a Box2D body and have faith that Box2D will do the rest.”</p>
         <pre>
class Box  {

<span class="callout-bubble">  Instead of any of the usual variables,</span>
              Body body;<span class="callout-bubble">  we will store a reference to a Box2D body.</span>
  float w;
  float h;
</pre>
         <p>We don’t need <em>(x,y)</em> anymore since, as we’ll see, the body itself will keep track of its location. The body technically could also keep track of the width and height for us, but since Box2D isn’t going to do anything to alter those values over the life of the <strong>Box</strong> object, we might as well just hold onto them ourselves until it’s time to draw the <strong>Box</strong>.</p>
         <p>Then, in our constructor, in addition to initializing the width and height, we can go ahead and include all of the body and shape code we learned in the previous two sections!</p>
         <pre>
  Box() {
    w = 16;
    h = 16;

    BodyDef bd = new BodyDef();<span class="callout-bubble">    Build body.</span>
    bd.type = BodyType.DYNAMIC;
    bd.position.set(box2d.coordPixelsToWorld(mouseX,mouseY));
    body = box2d.createBody(bd);

    PolygonShape ps = new PolygonShape();<span class="callout-bubble">    Build shape.</span>
    float box2dW = box2d.scalarPixelsToWorld(w/2);<span class="callout-bubble">    Box2D considers the width and height of a rectangle to be the distance from the center to the edge (so half of what we normally think of as width or height).</span>
    float box2dH = box2d.scalarPixelsToWorld(h/2);

    ps.setAsBox(box2dW, box2dH);

    FixtureDef fd = new FixtureDef();
    fd.shape = ps;
    fd.density = 1;
    fd.friction = 0.3;<span class="callout-bubble">    Set physics parameters.</span>
    fd.restitution = 0.5;

    body.createFixture(fd);<span class="callout-bubble">    Attach the Shape to the Body with the Fixture.</span>
 }
</pre>
         <p>OK, we’re almost there. Before we introduced Box2D, it was easy to draw the <strong klass="">Box</strong>. The object’s location was stored in variables <strong class="var">x</strong> and <strong class="var">y</strong>.<a data-primary="getBodyPixelCoord() function (PBox2D)" data-type="indexterm"> </a>
            <a data-primary="PBox2D helper class" data-secondary="getBodyPixelCoord() function (PBox2D)" data-type="indexterm"> </a>
         </p>
         <pre>
              void display() {<span class="callout-bubble">  Drawing the object using rect()</span>
    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }

</pre>
         <p>But now Box2D manages the object’s motion, so we can no longer use our own variables to display the shape. Not to fear! Our <strong klass="">Box</strong> object has a reference to the Box2D body associated with it. So all we need to do is politely ask the body, “Pardon me, where are you located?” Since this is a task we’ll need to do quite often, PBox2D includes a helper function: <strong function="">getBodyPixelCoord()</strong>.<a data-primary="getBodyPixelCoord() function (PBox2D)" data-type="indexterm"> </a>
            <a data-primary="PBox2D helper class" data-secondary="getBodyPixelCoord() function (PBox2D)" data-type="indexterm"> </a>
         </p>
         <pre>
Vec2 pos = box2d.getBodyPixelCoord(body);
</pre>
         <p>Just knowing the location of a body isn’t enough; we also need to know its angle of rotation.<a data-primary="getAngle() function (PBox2D)" data-type="indexterm"> </a>
         </p>
         <pre>
float a = body.getAngle();
</pre>
         <p>Once we have the location and angle, it’s easy to display the object using <strong function="">translate()</strong> and <strong function="">rotate()</strong>. Note, however, that the Box2D coordinate system considers rotation in the opposite direction from Processing, so we need to multiply the angle by -1.<a data-primary="rotate() function (PBox2D)" data-type="indexterm"> </a>
            <a data-primary="translate() function (PBox2D)" data-type="indexterm"> </a>
         </p>
         <figure id="chapter05_figure4">
            <img alt="Figure 5.4" src="../images/chapter05/ch05_04.png"/>
            <figcaption> </figcaption>
         </figure>
         <pre>
  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);<span class="callout-bubble">    We need the Body’s location and angle.</span>
    float a = body.getAngle();


    pushMatrix();
    translate(pos.x,pos.y);<span class="callout-bubble">    Using the Vec2 position and float angle to translate and rotate the rectangle</span>
    rotate(-a);

    fill(175);
    stroke(0);
    rectMode(CENTER);
    rect(0,0,w,h);
    popMatrix();
  }
</pre>
         <p>In case we want to have objects that can be removed from the Box2D world, it’s also useful to include a function to destroy a body, such as:<a data-primary="destroyBody() function (PBox2D)" data-type="indexterm"> </a>
         </p>
         <pre>
              void killBody() {<span class="callout-bubble">  This function removes a body from the Box2D world.</span>
    box2d.destroyBody(body);
  }
</pre>
         <aside data-type="sidebar" class="exercise">
            
            <figure class="screenshot">
               <img alt="ch05 exc02" src="../images/chapter05/ch05_exc02.png"/>
               <figcaption> </figcaption>
            </figure>
            <p>In this chapter’s code downloads, find the sketch named “box2d_exercise.” Using the methodology outlined in this chapter, add the necessary code to the main and Box tabs to implement Box2D physics. The result should appear as in the screenshot above. Be more creative in how you render the boxes.</p>
         </aside>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section8">
      <h1>Fixed Box2D Objects</h1>
      <p>In the example we just created, the <strong klass="">Box</strong> objects appear at the mouse location and fall downwards due to Box2D’s default gravity force. What if we wanted to install some immovable boundaries in the Box2D world that would block the path of the <strong klass="">Box</strong> objects (as in the illustration below)?<a data-primary="BodyDef type (body element)" data-secondary="STATIC type" data-type="indexterm"> </a>
         <a data-primary="boundaries" data-secondary="fixed" data-type="indexterm"> </a>
         <a data-primary="Box2D" data-secondary="fixed objects in" data-type="indexterm"> </a>
         <a data-primary="static (body type)" data-type="indexterm"> </a>
      </p>
      <p>Box2D makes this easy for us by providing a means to lock a body (and any associated shapes) in place. Just set the <strong>BodyDef</strong> object’s type to <strong class="var">STATIC</strong>.</p>
      <pre>
 BodyDef bd = new BodyDef();
<span class="callout-bubble"> When BodyDef type = STATIC, the</span>
          bd.type = BodyType.STATIC;<span class="callout-bubble"> Body is locked in place.</span>
</pre>
      <p>We can add this feature to our Boxes example by writing a <strong>Boundary</strong> class and having each boundary create a fixed Box2D body.</p>
      <figure class="screenshot">
         <img alt="ch05 ex02" src="../images/chapter05/ch05_ex02.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e1853" data-type="example">
         <h5>Falling boxes hitting boundaries</h5>
         <pre>
class Boundary {

  float x,y;<span class="callout-bubble">  A boundary is a simple rectangle with x, y, width, and height.</span>
  float w,h;

  Body b;

  Boundary(float x_,float y_, float w_, float h_) {
    x = x_;
    y = y_;
    w = w_;
    h = h_;

    BodyDef bd = new BodyDef();<span class="callout-bubble">    Build the Box2D Body and Shape.</span>
    bd.position.set(box2d.coordPixelsToWorld(x,y));
    bd.type = BodyType.STATIC;<span class="callout-bubble">    Make it fixed by setting type to STATIC!</span>
    b = box2d.createBody(bd);

    float box2dW = box2d.scalarPixelsToWorld(w/2);
    float box2dH = box2d.scalarPixelsToWorld(h/2);
    PolygonShape ps = new PolygonShape();
    ps.setAsBox(box2dW, box2dH);<span class="callout-bubble">    The PolygonShape is just a box.</span>

    b.createFixture(ps,1);<span class="callout-bubble">    Using the createFixture() shortcut</span>
  }

<span class="callout-bubble">  Since we know it can never move, we can just draw it</span>
            <span class="callout-bubble">  the old-fashioned way, using our original</span>
              void display() {<span class="callout-bubble">  variables. No need to query Box2D.</span>
    fill(0);
    stroke(0);
    rectMode(CENTER);
    rect(x,y,w,h);
  }

}
</pre>
      </div>
      
   </section>
   <section data-type="sect1" id="chapter05_section9">
      <h1>A Curvy Boundary</h1>
      <p>If you want a fixed boundary that is a curved surface (as opposed to a polygon), this can be achieved with the shape <strong klass="">ChainShape</strong>.<a data-primary="boundaries" data-secondary="curvy" data-type="indexterm"> </a>
         <a data-primary="ChainShape class" data-type="indexterm"> </a>
      </p>
      <p>The <strong>ChainShape</strong> class is another shape like <strong>PolygonShape</strong> or <strong>CircleShape</strong>, so to include one in our system, we follow the same steps.</p>
      <section data-type="sect2" id="_step_1_define_a_body_2">
         <h2>Step 1: Define a body.</h2>
         <pre>
            <span class="callout-bubble">The body does not need a position; the</span>
            <span class="callout-bubble">EdgeShape will take care of that for us.</span>
            <span class="callout-bubble">It also does not need a type, as it is STATIC</span>
            BodyDef bd = new BodyDef();<span class="callout-bubble">by default.</span>
Body body = box2d.world.createBody(bd);
</pre>
      </section>
      <section data-type="sect2" id="_step_2_define_the_shape">
         <h2>Step 2: Define the Shape.</h2>
         <pre>
ChainShape chain = new ChainShape();
</pre>
      </section>
      <section data-type="sect2" id="_step_3_configure_the_shape">
         <h2>Step 3: Configure the Shape.</h2>
         <p>The <strong klass="">ChainShape</strong> object is a series of connected vertices. To create the chain, we must first specify an array of vertices (each as a <strong klass="">Vec2</strong> object). For example, if we wanted a straight line from the left-hand side of our window to the right-hand side, we would just need an array of two vertices: (0,150) and (width,150).<a data-primary="ChainShape class" data-secondary="configuring" data-type="indexterm"> </a>
         </p>
         <pre>
Vec2[] vertices = new Vec2[2];
vertices[0] = box2d.coordPixelsToWorld(0,150);<span class="callout-bubble">Adding a vertex on the right side of window</span>
vertices[1] = box2d.coordPixelsToWorld(width,150);<span class="callout-bubble">Adding a vertex on the left side of window</span>
</pre>
         <p>To create the chain with the vertices, the array is then passed into a function called <strong function="">createChain()</strong>.   (Note that if you want to create a loop where the first vertex connects to the last vertex in a loop, you can use the <strong function="">createLoop()</strong> function instead.)</p>
         <pre>
            <span class="callout-bubble">If you don’t want to use the entire array,</span>
            chain.createChain(vertices, vertices.length);<span class="callout-bubble">you can specify a value less than length.</span>
</pre>
      </section>
      <section data-type="sect2" id="_step_4_attach_the_shape_to_the_body_with_a_fixture">
         <h2>Step 4: Attach the Shape to the body with a Fixture.</h2>
         <p>A <strong>Shape</strong> is not part of Box2D unless it is attached to a body. Even if it is a fixed boundary and never moves, it must still be attached. Just as with other shapes, a <strong>ChainShape</strong> object can be given properties like restitution and friction with a <strong>Fixture</strong>.</p>
         <pre>
FixtureDef fd = new FixtureDef();
fd.shape = chain;<span class="callout-bubble">A fixture assigned to the ChainShape</span>
fd.density = 1;
fd.friction = 0.3;
fd.restitution = 0.5;

body.createFixture(fd);
</pre>
         <p>Now, if we want to include a <strong>ChainShape</strong> object in our sketch, we can follow the same strategy as we did with a fixed boundary. Let’s write a class called <strong>Surface</strong>:</p>
         <figure class="screenshot">
            <img alt="ch05 ex04" src="../images/chapter05/ch05_ex04.png"/>
            <figcaption> </figcaption>
         </figure>
         <div id="example_d1e2034" data-type="example">
            <h5>ChainShape with three hard-coded vertices</h5>
            <pre>
class Surface {
  ArrayList&lt;Vec2&gt; surface;

  Surface() {

    surface = new ArrayList&lt;Vec2&gt;();
    surface.add(new Vec2(0, height/2+50));<span class="callout-bubble">    3 vertices in pixel coordinates</span>
    surface.add(new Vec2(width/2, height/2+50));
    surface.add(new Vec2(width, height/2));


    ChainShape chain = new ChainShape();

    Vec2[] vertices = new Vec2[surface.size()];<span class="callout-bubble">    Make an array of Vec2 for the ChainShape.</span>


    for (int i = 0; i &lt; vertices.length; i++) {
      vertices[i] = box2d.coordPixelsToWorld(surface.get(i));<span class="callout-bubble">      Convert each vertex to Box2D World coordinates.</span>
    }

    chain.createChain(vertices, vertices.length);<span class="callout-bubble">    Create the ChainShape with array of Vec2.</span>

    BodyDef bd = new BodyDef();<span class="callout-bubble">    Attach the Shape to the Body.</span>
    Body body = box2d.world.createBody(bd);
    body.createFixture(chain, 1);

  }
</pre>
         </div>
         
         <p>Notice how the above class includes an <strong>ArrayList</strong> to store a series of <strong>Vec2</strong> objects. Even though we fully intend to store the coordinates of the chain in the chain shape itself, we are choosing the ease of redundancy and keeping our own list of those points as well. Later, when we go to draw the <strong>Surface</strong> object, we don’t have to ask Box2D for the locations of the chain shape’s vertices.</p>
         <pre>
  void display() {
    strokeWeight(1);
    stroke(0);
    noFill();
    beginShape();<span class="callout-bubble">    Draw the ChainShape as a series of vertices.</span>
    for (Vec2 v: surface) {
      vertex(v.x,v.y);
    }

    endShape();
  }
}
</pre>
         <p>What we need in <strong function="">setup()</strong> and <strong function="">draw()</strong> for the <strong>Surface</strong> object is quite simple, given that Box2D takes care of all of the physics for us.</p>
         <pre>
PBox2D box2d;

Surface surface;

void setup() {
  size(500,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  surface = new Surface();<span class="callout-bubble">  Make a Surface object.</span>
}

void draw() {
  box2d.step();

  background(255);
  surface.display();<span class="callout-bubble">  Draw the Surface.</span>
}
</pre>
         <aside data-type="sidebar" class="exercise">
            
            <p>Review how we learned to draw a wave pattern in Chapter 3. Create a <strong>ChainShape</strong> object out of a sine wave. Try using <a href="#intro_section6">Perlin noise</a> as well.</p>
            <figure class="two-col">
               <img alt="sine wave" src="../images/chapter05/ch05_exc03a.png"/>
               <figcaption> </figcaption>
            </figure>
            <figure class="two-col">
               <img alt="Perlin noise" src="../images/chapter05/ch05_exc03b.png"/>
               <figcaption> </figcaption>
            </figure>
            <figure>
               <img alt="blank" src="../images/blank.png"/>
               <figcaption> </figcaption>
            </figure>
         </aside>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section10">
      <h1>Complex Forms</h1>
      <figure class="half-width-right" id="chapter05_figure5">
         <img alt="Figure 5.5" src="../images/chapter05/ch05_05.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>Now that we’ve seen how easy it is to make simple geometric forms in Box2D, let’s imagine that you want to have a more complex form, such as a little alien stick figure.<a data-primary="Box2D" data-secondary="complex forms in" data-type="indexterm"> </a>
      </p>
      <p>There are two strategies in Box2D for making forms that are more advanced than a basic circle or square. One is to use a <strong klass="">PolygonShape</strong> in a different way. In our previous examples, we used <strong klass="">PolygonShape</strong> to generate a rectangular shape with the <strong function="">setAsBox()</strong> function.<a data-primary="PolygonShape class" data-secondary="as list of vectors" data-type="indexterm"> </a>
      </p>
      <pre>
  PolygonShape ps = new PolygonShape();
  ps.setAsBox(box2dW, box2dH);
</pre>
      <p>This was a good way to start because of the inherent simplicity of working with rectangles. However, a <strong klass="">PolygonShape</strong> object can also be generated from an array of vectors, which allows you to build a completely custom shape as a series of connected vertices. This works very similarly to the <strong klass="">ChainShape</strong> class.<a data-primary="PolygonShape class" data-secondary="as list of vectors" data-type="indexterm"> </a>
      </p>
      <figure class="screenshot">
         <img alt="ch05 ex05" src="../images/chapter05/ch05_ex05.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e2197" data-type="example">
         <h5>Polygon shapes</h5>
         <pre>
            vertices[0] = box2d.vectorPixelsToWorld(new Vec2(-15, 25));<span class="callout-bubble">Vec2[] vertices = new Vec2[4];	An array of 4 vectors</span>
vertices[1] = box2d.vectorPixelsToWorld(new Vec2(15, 0));
vertices[2] = box2d.vectorPixelsToWorld(new Vec2(20, -15));
vertices[3] = box2d.vectorPixelsToWorld(new Vec2(-10, -10));

PolygonShape ps = new PolygonShape();<span class="callout-bubble">Making a polygon from that array</span>
ps.set(vertices, vertices.length);

</pre>
      </div>
      
      <p>When building your own polygon in Box2D, you must remember two important details.<a data-primary="Box2D" data-secondary="order of vertices" data-type="indexterm"> </a>
      </p>
      <figure class="half-width-left" id="chapter05_figure6">
         <img alt="Figure 5.6" src="../images/chapter05/ch05_06.png"/>
         <figcaption> </figcaption>
      </figure>
      <ol>
         <li>
            <p>
               <strong>Order of vertices!</strong> If you are thinking in terms of pixels (as above) the vertices should be defined in counterclockwise order. (When they are translated to Box2D World vectors, they will actually be in clockwise order since the vertical axis is flipped.)</p>
         </li>
         <li>
            <p>
               <strong>Convex shapes only!</strong> A concave shape is one where the surface curves inward. Convex is the opposite (see illustration below). Note how in a convex shape every internal angle must be 180 degrees or less. Box2D is not capable of handling collisions for concave shapes. If you need a concave shape, you will have to build one out of multiple convex shapes (more about that in a moment).</p>
         </li>
      </ol>
      <figure>
         <img alt="Figure 5.7: A concave shape can be drawn with multiple convex shapes." src="../images/chapter05/ch05_07.png"/>
         <figcaption>A concave shape can be drawn with multiple convex shapes.</figcaption>
      </figure>
      <p>Now, when it comes time to display the shape in Processing, we can no longer just use <strong function="">rect()</strong> or <strong function="">ellipse()</strong>. Since the shape is built out of custom vertices, we’ll want to use Processing’s <strong function="">beginShape()</strong>, <strong function="">endShape()</strong>, and <strong function="">vertex()</strong> functions. As we saw with the <strong>ChainShape</strong>, we could choose to store the pixel locations of the vertices in our own <strong>ArrayList</strong> for drawing. However, it’s also useful to see how we can ask Box2D to report back to use the vertex locations.</p>
      <pre>
  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    Fixture f = body.getFixtureList();<span class="callout-bubble">    First we get the Fixture attached to the body...</span>
    PolygonShape ps = (PolygonShape) f.getShape();<span class="callout-bubble">    ...then the Shape attached to the Fixture.</span>

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    beginShape();
    for (int i = 0; i &lt; ps.getVertexCount(); i++) {<span class="callout-bubble">    We can loop through that array and convert each vertex from Box2D space to pixels.</span>
      Vec2 v = box2d.vectorWorldToPixels(ps.getVertex(i));
      vertex(v.x,v.y);
    }
    endShape(CLOSE);
    popMatrix();
  }
</pre>
      <aside data-type="sidebar" class="exercise">
         
         <p>Using the <strong>PolygonShape</strong> class, create your own polygon design (remember, it must be convex). Some possibilities below.</p>
         <figure>
            <img alt="ch05 exc04" src="../images/chapter05/ch05_exc04.png"/>
            <figcaption> </figcaption>
         </figure>
      </aside>
      <p>A polygon shape will get us pretty far in Box2D. Nevertheless, the convex shape requirement will severely limit the range of possibilities. The good news is that we can completely eliminate this restriction by creating a single Box2D body out of multiple shapes! Let’s return to our little alien creature and simplify the shape to be a thin rectangle with a circle on top.<a data-primary="body (Box2D element)" data-secondary="multiple shapes and" data-type="indexterm"> </a>
      </p>
      <p>How can we build a single body with two shapes? Let’s first review how we built a single body with one shape.</p>
      <p>
         <em>Step 1: Define the body.</em>
         <br/>
         <em>Step 2: Create the body.</em>
         <br/>
         <strong>
            <em>Step 3: Define the shape.</em>
         </strong>
         <br/>
         <strong>
            <em>Step 4: Attach the shape to the body.</em>
         </strong>
         <br/>
         <em>Step 5: Finalize the body’s mass.</em>
      </p>
      <p>Attaching more than one shape to a body is as simple as repeating steps 3 and 4 over and over again.</p>
      <p>
         <strong>
            <em>Step 3a: Define shape 1.</em>
         </strong>
         <br/>
         <strong>
            <em>Step 4a: Attach shape 1 to the body.</em>
         </strong>
         <br/>
         <strong>
            <em>Step 3b: Define shape 2.</em>
         </strong>
         <br/>
         <strong>
            <em>Step 4b: Attach shape 2 to the body.</em>
         </strong>
         <br/>
etc. etc. etc.</p>
      <p>Let’s see what this would look like with actual Box2D code.</p>
      <pre>
         BodyDef bd = new BodyDef();<span class="callout-bubble">Making the body</span>
bd.type = BodyType.DYNAMIC;
bd.position.set(box2d.coordPixelsToWorld(center));
body = box2d.createBody(bd);


PolygonShape ps = new PolygonShape();<span class="callout-bubble">Making shape 1 (the rectangle)</span>
float box2dW = box2d.scalarPixelsToWorld(w/2);
float box2dH = box2d.scalarPixelsToWorld(h/2);
sd.setAsBox(box2dW, box2dH);


CircleShape cs = new CircleShape();<span class="callout-bubble">Making shape 2 (the circle)</span>
cs.m_radius = box2d.scalarPixelsToWorld(r);


body.createFixture(ps,1.0);<span class="callout-bubble">Attach both shapes with a fixture.</span>
body.createFixture(cs, 1.0);

</pre>
      <p>The above looks pretty good, but sadly, if we run it, we’ll get the following result:</p>
      <figure id="chapter05_figure8">
         <img alt="Figure 5.8" src="../images/chapter05/ch05_08.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>When you attach a shape to a body, by default, the center of the shape will be located at the center of the body. But in our case, if we take the center of the rectangle to be the center of the body, we want the center of the circle to be offset along the y-axis from the body’s center.<a data-primary="m_p variable (Vec2 class)" data-type="indexterm"> </a>
         <a data-primary="Shape (Box2D element)" data-secondary="local position for" data-type="indexterm"> </a>
      </p>
      <figure id="chapter05_figure9">
         <img alt="Figure 5.9" src="../images/chapter05/ch05_09.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>This is achieved by using the local position of a shape, accessed via a <strong klass="">Vec2</strong> variable called <strong class="var">m_p</strong>.<a data-primary="m_p variable (Vec2 class)" data-type="indexterm"> </a>
         <a data-primary="Shape (Box2D element)" data-secondary="local position for" data-type="indexterm"> </a>
      </p>
      <pre>
         Vec2 offset = new Vec2(0,-h/2);<span class="callout-bubble">Our offset in pixels</span>
offset = box2d.vectorPixelsToWorld(offset);<span class="callout-bubble">Converting the vector to Box2D world</span>
circle.m_p.set(offset.x,offset.y);<span class="callout-bubble">Setting the local position of the circle</span>
</pre>
      <p>Then, when we go to draw the body, we use both <strong function="">rect()</strong> and <strong function="">ellipse()</strong> with the circle offset the same way.</p>
      <figure class="screenshot">
         <img alt="ch05 ex06" src="../images/chapter05/ch05_ex06.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e2487" data-type="example">
         <h5>Multiple shapes on one body</h5>
         <pre>
  void display() {
    Vec2 pos = box2d.getBodyPixelCoord(body);
    float a = body.getAngle();

    rectMode(CENTER);
    pushMatrix();
    translate(pos.x,pos.y);
    rotate(-a);
    fill(175);
    stroke(0);
    rect(0,0,w,h);<span class="callout-bubble">    First the rectangle at (0,0)</span>
    ellipse(0,-h/2,r*2,r*2);<span class="callout-bubble">    Then the ellipse offset at (0,-h/2)</span>
    popMatrix();
  }
</pre>
      </div>
      
      <p>Finishing off this section, I want to stress the following: the stuff you draw in your Processing window doesn’t magically experience physics simply because we created some Box2D bodies and shapes. These examples work because we very carefully matched how we draw our elements with how we defined the bodies and shapes we put into the Box2D world. If you accidentally draw your shape differently, you won’t get an error, not from Processing or from Box2D. However, your sketch will look odd and the physics won’t work correctly. For example, what if we had written:</p>
      <pre>
Vec2 offset = new Vec2(0,-h/2);
</pre>
      <p>when we created the shape, but:</p>
      <pre>
ellipse(0,h/2,r*2,r*2);
</pre>
      <p>when it came time to display the shape?</p>
      <figure class="screenshot">
         <img alt="ch05 ex07" src="../images/chapter05/ch05_ex07.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>The results would look like the image above, where clearly, the collisions are not functioning as expected. This is not because the physics is broken; it’s because we did not communicate properly with Box2D, either when we put stuff in the magic world or queried the world for locations.</p>
      <aside data-type="sidebar" class="exercise">
         
         <p>Make your own little alien being using multiple shapes attached to a single body. Try using more than one polygon to make a concave shape. Remember, you aren’t limited to using the shape drawing functions in Processing; you can use images, colors, add hair with lines, etc. Think of the Box2D shapes only as skeletons for your creative and fantastical design!</p>
      </aside>
   </section>
   <section data-type="sect1" id="chapter05_section11">
      <h1>Feeling Attached—Box2D Joints</h1>
      <figure class="half-width-right" id="chapter05_figure10">
         <img alt="Figure 5.10" src="../images/chapter05/ch05_10.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>Box2D joints allow you to connect one body to another, enabling more advanced simulations of swinging pendulums, elastic bridges, squishy characters, wheels spinning on an axle, etc. There are many different kinds of Box2D joints. In this chapter we’re going to look at three: distance joints, revolute joints, and “mouse” joints.</p>
      <p>Let’s begin with a distance joint, a joint that connects two bodies with a fixed length. The joint is attached to each body at a specified anchor point (a point relative to the body’s center). For any Box2D joint, we need to follow these steps. This, of course, is similar to the methodology we used to build bodies and shapes, with some quirks.<a data-primary="distance joints" data-type="indexterm"> </a>
         <a data-primary="joint (Box2D element)" data-secondary="distance" data-type="indexterm"> </a>
      </p>
      <p>
         <strong>
            <em>Step 1. Make sure you have two bodies ready to go.</em>
         </strong>
         <br/>
         <strong>
            <em>Step 2. Define the joint.</em>
         </strong>
         <br/>
         <strong>
            <em>Step 3. Configure the joint’s properties (What are the bodies? Where are the anchors? What is its rest length? Is it elastic or rigid?)</em>
         </strong>
         <br/>
         <strong>
            <em>Step 4. Create the joint.</em>
         </strong>
      </p>
      <p>Let’s assume we have two <strong klass="">Particle</strong> objects that each store a reference to a Box2D <strong klass="">Body</strong> object. We’ll call them particles <strong class="var">p1</strong> and <strong class="var">p2</strong>.<a data-primary="DistanceJointDef (Box2D joint type)" data-type="indexterm"> </a>
      </p>
      <pre>
Particle p1 = new Particle();
Particle p2 = new Particle();
</pre>
      <p>OK, onto Step 2. Let’s define the joint.<a data-primary="DistanceJointDef (Box2D joint type)" data-type="indexterm"> </a>
      </p>
      <pre>
DistanceJointDef djd = new DistanceJointDef();
</pre>
      <p>Easy, right? Now it’s time to configure the joint. First we tell the joint which two bodies it connects:<a data-primary="rest length (Box2D joint element)" data-type="indexterm"> </a>
      </p>
      <pre>
djd.bodyA = p1.body;
djd.bodyB = p2.body;
</pre>
      <p>Then we set up a rest length. Remember, if our rest length is in pixels, we need to convert it!</p>
      <pre>
djd.length = box2d.scalarPixelsToWorld(10);
</pre>
      <p>A distance joint also includes two optional settings that can make the joint soft, like a spring connection: <strong class="var">frequencyHz</strong> and <strong class="var">dampingRatio</strong>.<a data-primary="dampingRatio setting (Box2D joint element)" data-type="indexterm"> </a>
         <a data-primary="frequencyHz setting (Box2D joint element)" data-type="indexterm"> </a>
      </p>
      <pre>
         <span class="callout-bubble">  Measured in Hz, like the frequency of harmonic</span>
           djd.frequencyHz  = ___;<span class="callout-bubble">  oscillation; try values between 1 and 5.</span>
  djd.dampingRatio = ___;<span class="callout-bubble">  Dampens the spring; typically a number between 0 and 1.</span>
</pre>
      <p>Finally, we create the joint.</p>
      <pre>
DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);
</pre>
      <p>Box2D won’t keep track of what kind of joint we are making, so we have to cast it as a <strong>DistanceJoint</strong> upon creation.</p>
      <p>We can create Box2D joints anywhere in our Processing sketch. Here’s an example of how we might write a class to describe two Box2D bodies connected with a single joint.<a data-primary="joint (Box2D element)" data-secondary="revolute type" data-type="indexterm"> </a>
         <a data-primary="revolute joint type (Box2D)" data-type="indexterm"> </a>
      </p>
      <figure class="screenshot">
         <img alt="ch05 ex08" src="../images/chapter05/ch05_ex08.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e2703" data-type="example">
         <h5>DistanceJoint</h5>
         <pre>
class Pair {

  Particle p1;<span class="callout-bubble">  Two objects that each have a Box2D body</span>
  Particle p2;

  float len = 32;<span class="callout-bubble">  Arbitrary rest length</span>

  Pair(float x, float y) {

<span class="callout-bubble">    //[full]</span>
            <span class="callout-bubble">    Problems can result if the bodies are initialized at the same location.</span>
    p1 = new Particle(x,y);
    p2 = new Particle(x+random(-1,1),y+random(-1,1));


    DistanceJointDef djd = new DistanceJointDef();<span class="callout-bubble">    Making the joint!</span>
    djd.bodyA = p1.body;
    djd.bodyB = p2.body;
    djd.length = box2d.scalarPixelsToWorld(len);
<span class="callout-bubble">    djd.frequencyHz = 0;  Try a value less than 5</span>
            <span class="callout-bubble">    djd.dampingRatio = 0; Ranges between 0 and 1</span>
                DistanceJoint dj = (DistanceJoint) box2d.world.createJoint(djd);<span class="callout-bubble">    Make the joint.  Note that we aren't storing a reference to the joint anywhere! We might need to someday, but for now it's OK.</span>
  }

  void display() {
    Vec2 pos1 = box2d.getBodyPixelCoord(p1.body);
    Vec2 pos2 = box2d.getBodyPixelCoord(p2.body);
    stroke(0);
    line(pos1.x,pos1.y,pos2.x,pos2.y);

    p1.display();
    p2.display();
  }
}
</pre>
      </div>
      
      <aside data-type="sidebar" class="exercise">
         
         <p>Create a simulation of a bridge by using distance joints to connect a sequence of circles (or rectangles) as illustrated to the right. Assign a density of zero to lock the endpoints in place. Experiment with different values to make the bridge more or less “springy.” It should also be noted that the joints themselves have no physical geometry, so in order for your bridge not to have holes, spacing between the nodes will be important.</p>
         <figure class="screenshot">
            <img alt="ch05 exc06" src="../images/chapter05/ch05_exc06.png"/>
            <figcaption> </figcaption>
         </figure>
      </aside>
      <figure class="half-width-right" id="chapter05_figure11">
         <img alt="Figure 5.11" src="../images/chapter05/ch05_11.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>Another joint you can create in Box2D is a <em>revolute joint</em>. A revolute joint connects two Box2D bodies at a common anchor point, which can also be referred to as a “hinge.” The joint has an “angle” that describes the relative rotation of each body. To use a revolute joint, we follow the same steps we did with the distance joint.<a data-primary="joint (Box2D element)" data-secondary="revolute type" data-type="indexterm"> </a>
         <a data-primary="revolute joint type (Box2D)" data-type="indexterm"> </a>
      </p>
      <section data-type="sect2" id="_step_1_make_sure_you_have_two_bodies_ready_to_go">
         <h2>Step 1: Make sure you have two bodies ready to go.</h2>
         <p>Let’s assume we have two <strong>Box</strong> objects, each of which stores a reference to a Box2D body.</p>
         <pre>
Box box1 = new Box();
Box box2 = new Box();
</pre>
      </section>
      <section data-type="sect2" id="_step_2_define_the_joint">
         <h2>Step 2: Define the joint.</h2>
         <p>Now we want a <strong klass="">RevoluteJointDef</strong> object.<a data-primary="RevoluteJointDef object (Box2D joint element)" data-type="indexterm"> </a>
         </p>
         <pre>
RevoluteJointDef rjd = new RevoluteJointDef();
</pre>
      </section>
      <section data-type="sect2" id="_step_3_configure_the_joint_s_properties">
         <h2>Step 3: Configure the joint’s properties.</h2>
         <p>The most important properties of a revolute joint are the two bodies it connects as well as their mutual anchor point (i.e. where they are connected). They are set with the function <strong function="">initialize()</strong>.<a data-primary="revolute joint type (Box2D)" data-secondary="properties" data-tertiary="configuring" data-type="indexterm"> </a>
         </p>
         <pre>
rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());
</pre>
         <p>Notice how the first two arguments specify the bodies and the second point specifies the anchor, which in this case is located at the center of the first body.</p>
         <p>An exciting feature of a <strong>RevoluteJoint</strong> object is that you can motorize it so it spins autonomously. For example:</p>
         <pre>
            rjd.enableMotor = true;<span class="callout-bubble">Turn on the motor.</span>
rjd.motorSpeed = PI*2;<span class="callout-bubble"> How fast is the motor?</span>
rjd.maxMotorTorque = 1000.0;<span class="callout-bubble">How powerful is the motor?</span>
</pre>
         <p>The motor can be enabled and disabled while the program is running.</p>
         <p>Finally, the ability for a revolute joint to spin can be constrained between two angles. (By default, it can rotate a full 360 degrees, or <strong class="var">TWO_PI</strong> radians.)</p>
         <pre>
rjd.enableLimit = true;
rjd.lowerAngle = -PI/8;
rjd.upperAngle = PI/8;
</pre>
      </section>
      <section data-type="sect2" id="_step_4_create_the_joint">
         <h2>Step 4: Create the joint.</h2>
         <pre>
RevoluteJoint joint = (RevoluteJoint) box2d.world.createJoint(rjd);
</pre>
         <p>Let’s take a look at all of these steps together in a class called <strong klass="">Windmill</strong>, which connects two boxes with a revolute joint. In this case, <strong class="var">box1</strong> has a density of zero, so only <strong class="var">box2</strong> spins around a fixed point.<a data-primary="joint (Box2D element)" data-secondary="mouse type" data-type="indexterm"> </a>
            <a data-primary="mouse joint (Box2D Joint type)" data-type="indexterm"> </a>
         </p>
         <figure class="screenshot">
            <img alt="ch05 ex09" src="../images/chapter05/ch05_ex09.png"/>
            <figcaption> </figcaption>
         </figure>
         <div id="example_d1e2894" data-type="example">
            <h5>Spinning Windmill</h5>
            <pre>
class Windmill {

  RevoluteJoint joint;<span class="callout-bubble">  Our “Windmill” is two boxes and one joint.</span>
  Box box1;
  Box box2;

  Windmill(float x, float y) {

    box1 = new Box(x,y,120,10,false);<span class="callout-bubble">    In this example, the Box class expects a boolean argument that will be used to determine if the Box is fixed or not.  See website for the Box class code.</span>
    box2 = new Box(x,y,10,40,true);




    RevoluteJointDef rjd = new RevoluteJointDef();
    rjd.initialize(box1.body, box2.body, box1.body.getWorldCenter());<span class="callout-bubble">    The joint connects two bodies and is anchored at the center of the first body.</span>



    rjd.motorSpeed = PI*2;<span class="callout-bubble">    A motor!</span>
    rjd.maxMotorTorque = 1000.0;
    rjd.enableMotor = true;

    joint = (RevoluteJoint) box2d.world.createJoint(rjd);<span class="callout-bubble">    Create the Joint.</span>
  }

  void toggleMotor() {<span class="callout-bubble">  Turning the motor on or off</span>
    boolean motorstatus = joint.isMotorEnabled();
    joint.enableMotor(!motorstatus);
  }


  void display() {
    box1.display();
    box2.display();
  }
}
</pre>
         </div>
         
         <aside data-type="sidebar" class="exercise">
            
            <figure class="half-width-right">
               <img alt="ch05 exc07" src="../images/chapter05/ch05_exc07.png"/>
               <figcaption> </figcaption>
            </figure>
            <p>Use a revolute joint for the wheels of a car. Use motors so that the car drives autonomously. Try using a chain shape for the road’s surface.</p>
            <figure>
               <img alt="blank" src="../images/blank.png"/>
               <figcaption> </figcaption>
            </figure>
         </aside>
         <p>The last joint we’ll look at is a mouse joint. A mouse joint is typically used for moving a body with the mouse. However, it can also be used to drag an object around the screen according to some arbitrary <em>x</em> and <em>y</em>. The joint functions by pulling the body towards a “target” position.</p>
         <p>Before we look at the <strong klass="">MouseJoint</strong> object itself, let’s ask ourselves why we even need it in the first place. If you look at the Box2D documentation, there is a function called <strong function="">setTransform()</strong> that specifically “sets the position of the body’s origin and rotation (radians).” If a body has a position, can’t we just assign the body’s position to the mouse?<a data-primary="mouse joint (Box2D joint type)" data-secondary="setTransform() function" data-type="indexterm"> </a>
            <a data-primary="setTransform() function (Box2D)" data-type="indexterm"> </a>
         </p>
         <pre>
Vec2 mouse = box2d.screenToWorld(x,y);
body.setTransform(mouse,0);
</pre>
         <p>While this will in fact move the body, it will also have the unfortunate result of breaking the physics. Let’s imagine you built a teleportation machine that allows you to teleport from your bedroom to your kitchen (good for late-night snacking). Now, go ahead and rewrite Newton’s laws of motion to account for the possibility of teleportation. Not so easy, right? Box2D has the same problem. If you manually assign the location of an body, it’s like saying “teleport that body” and Box2D no longer knows how to compute the physics properly. However, Box2D does allow you to tie a rope to yourself and get a friend of yours to stand in the kitchen and drag you there. This is what the <strong>MouseJoint</strong> does. It’s like a string you attach to a body and pull towards a target.</p>
         <p>Let’s look at making this joint, assuming we have a <strong klass="">Box</strong> object called <strong class="var">box</strong>. This code will look identical to our distance joint with one small difference.<a data-primary="getGroundBody() function (Box2D joint element)" data-type="indexterm"> </a>
         </p>
         <pre>
            MouseJointDef md = new MouseJointDef();<span class="callout-bubble">Just like before, define the Joint.</span>

<span class="callout-bubble">Whoa, this is new!</span>
            <em class="strong">md.bodyA = box2d.getGroundBody(); //[bold]</em>
            md.bodyB = box.body;<span class="callout-bubble">Attach the Box body.</span>

md.maxForce = 5000.0;<span class="callout-bubble">Set properties.</span>
md.frequencyHz = 5.0;
md.dampingRatio = 0.9;

MouseJoint mouseJoint = (MouseJoint) box2d.world.createJoint(md);.<span class="callout-bubble">Create the joint.</span>
</pre>
         <p>So, what’s this line of code all about?<a data-primary="getGroundBody() function (Box2D joint element)" data-type="indexterm"> </a>
         </p>
         <pre>
            <em class="strong">md.bodyA = box2d.getGroundBody(); //[bold]</em>
         </pre>
         <p>Well, as we’ve stated, a joint is a connection between <em>two</em> bodies. With a mouse joint, we’re saying that the second body is, well, the ground. Hmm. What the heck is the <em>ground</em> in Box2D? One way to imagine it is to think of the screen as the ground. What we’re doing is making a joint that connects a rectangle drawn on the window with the Processing window itself. And the point in the window to which the connection is tied is a moving target.</p>
         <p>Once we have a mouse joint, we’ll want to update the target location continually while the sketch is running.</p>
         <pre>
Vec2 mouseWorld = box2d.coordPixelsToWorld(mouseX,mouseY);
mouseJoint.setTarget(mouseWorld);
</pre>
         <p>To make this work in an actual Processing sketch, we’ll want to have the following:</p>
         <ol>
            <li>
               <p>
                  <strong>
                     <em>Box class</em>
                  </strong>
                  <code>—</code>An object that references a Box2D body.</p>
            </li>
            <li>
               <p>
                  <strong>
                     <em>Spring class</em>
                  </strong>
                  <code>—</code>An object that manages the mouse joint that drags the <strong>Box</strong> object around.</p>
            </li>
            <li>
               <p>
                  <strong>
                     <em>Main tab</em>
                  </strong>
                  <code>—</code>Whenever <strong function="">mousePressed()</strong> is called, the mouse joint is created; whenever <strong function="">mouseReleased()</strong> is called, the mouse joint is destroyed. This allows us to interact with a body only when the mouse is pressed.</p>
            </li>
         </ol>
         <p>Let’s take a look at the main tab. You can find the rest of the code for the <strong klass="">Box</strong> and <strong klass="">Spring</strong> classes via the book website.<a data-primary="kinematic (body type)" data-secondary="MouseJoints and" data-type="indexterm"> </a>
         </p>
         <figure class="screenshot">
            <img alt="ch05 ex10" src="../images/chapter05/ch05_ex10.png"/>
            <figcaption> </figcaption>
         </figure>
         <div id="example_d1e3124" data-type="example">
            <h5>MouseJoint demonstration</h5>
            <pre>
PBox2D box2d;

Box box;<span class="callout-bubble">One Box</span>
Spring spring;<span class="callout-bubble">Object to manage MouseJoint</span>

void setup() {
  size(400,300);
  box2d = new PBox2D(this);
  box2d.createWorld();

  box = new Box(width/2,height/2);
  spring = new Spring();<span class="callout-bubble">  The MouseJoint is really null until we click the mouse.</span>
}

void mousePressed() {
  if (box.contains(mouseX, mouseY)) {<span class="callout-bubble">  Was the mouse clicked inside the Box?</span>
    spring.bind(mouseX,mouseY,box);<span class="callout-bubble">    If so, attach the MouseJoint.</span>
  }
}

void mouseReleased() {
  spring.destroy();<span class="callout-bubble">  When the mouse is released, we’re done with the MouseJoint.</span>
}

void draw() {
  background(255);

  box2d.step();

  spring.update(mouseX,mouseY);<span class="callout-bubble">  We must always update the MouseJoint’s target.</span>

  box.display();
  spring.display();
}
</pre>
         </div>
         
         <aside data-type="sidebar" class="exercise">
            
            <p>Use a mouse joint to move a Box2D body around the screen according to an algorithm or input other than the mouse. For example, assign it a location according to Perlin noise or key presses. Or build your own controller using an <a href="http://www.arduino.cc/">Arduino</a>.</p>
         </aside>
         <p>It’s worth noting that while the technique for dragging an object around using a <strong klass="">MouseJoint</strong> is useful, Box2D also allows a body to have a <strong class="var">KINEMATIC</strong> type.<a data-primary="kinematic (body type)" data-secondary="MouseJoints and" data-type="indexterm"> </a>
         </p>
         <pre>
BodyDef bd = new BodyDef();
bd.type = BodyType.KINEMATIC;<span class="callout-bubble">Setting the body type to Kinematic</span>
</pre>
         <figure class="half-width-right" id="chapter05_figure12">
            <img alt="Figure 5.12" src="../images/chapter05/ch05_12.png"/>
            <figcaption> </figcaption>
         </figure>
         <p>Kinematic bodies can be controlled by the user by setting their velocity directly. For example, let’s say you want an object to follow a target (like your mouse). You could create a vector that points from a body’s location to a target.</p>
         <pre>
Vec2 pos = body.getWorldCenter();
Vec2 target = box2d.coordPixelsToWorld(mouseX,mouseY);
Vec2 v = target.sub(pos);<span class="callout-bubble">A vector pointing from the body position to the Mouse</span>
</pre>
         <p>Once you have that vector, you could assign it to the body’s velocity so that it moves to the target.</p>
         <pre>
            body.setLinearVelocity(v);<span class="callout-bubble">Assigning a body’s velocity directly, overriding physics!</span>
</pre>
         <p>You can also do the same with angular velocity (or leave it alone and allow the physics to take over).</p>
         <p>It is important to note that kinematic bodies do not collide with other kinematic or static bodies. In these cases, the mouse joint strategy is preferable.</p>
         <aside data-type="sidebar" class="exercise">
            
            <p>Redo Exercise 5.8, but use a kinematic body instead.</p>
         </aside>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section12">
      <h1>Bringing It All Back Home to Forces</h1>
      <p>In Chapter 2, we spent a lot of time thinking about building environments with multiple forces. An object might respond to gravitational attraction, wind, air resistance, etc. Clearly there are forces at work in Box2D as we watch rectangles and circles spin and fly around the screen. But so far, we’ve only had the ability to manipulate a single global force—gravity.<a data-primary="applyForce() function (Box2D)" data-type="indexterm"> </a>
         <a data-primary="forces" data-secondary="applyForce() function" data-type="indexterm"> </a>
      </p>
      <pre>
  box2d = new PBox2D(this);
  box2d.createWorld();
  box2d.setGravity(0, -20);<span class="callout-bubble">  Setting the global gravity force</span>
</pre>
      <p>If we want to use any of our Chapter 2 techniques with Box2D, we need look no further than our trusty <strong function="">applyForce()</strong> function. In our <strong klass="">Mover</strong> class we wrote a function called <strong function="">applyForce()</strong>, which received a vector, divided it by mass, and accumulated it into the mover’s acceleration. With Box2D, the same function exists, but we don’t need to write it ourselves. Instead, we can call the Box2D body’s <strong function="">applyForce()</strong> function!<a data-primary="applyForce() function (Box2D)" data-type="indexterm"> </a>
         <a data-primary="forces" data-secondary="applyForce() function" data-type="indexterm"> </a>
      </p>
      <pre>
class Box {
  Body body;

  void applyForce(Vec2 force) {
    Vec2 pos = body.getWorldCenter();
    body.applyForce(force, pos);<span class="callout-bubble">    Calling the Body's applyForce() function</span>
  }
}
</pre>
      <p>Here we are receiving a force vector and passing it along to the Box2D <strong>Body</strong> object. The key difference is that Box2D is a more sophisticated engine than our examples from Chapter 2. Our earlier forces examples assumed that the force was always applied at the mover’s center. Here we get to specify exactly where on the body the force is applied. In the above code, we’re just applying it to the center by asking the body for its center, but this could be adjusted.</p>
      <p>Let’s say we wanted to use a gravitational attraction force. Remember the code we wrote back in Chapter 2 in our <strong>Attractor</strong> class?</p>
      <pre>
PVector attract(Mover m) {
  PVector force = PVector.sub(location,m.location);
  float distance = force.mag();
  distance = constrain(distance,5.0,25.0);
  force.normalize();
  float strength = (g * mass * m.mass) / (distance * distance);
  force.mult(strength);
  return force;
}
</pre>
      <p>We can rewrite the exact same function using <strong>Vec2</strong> instead and use it in a Box2D example. Note how for our force calculation we can stay completely within the Box2D coordinate system and never think about pixels.</p>
      <pre>
Vec2 attract(Mover m) {
  Vec2 pos = body.getWorldCenter();<span class="callout-bubble">  We have to ask Box2D for the locations first!</span>
  Vec2 moverPos = m.body.getWorldCenter();
  Vec2 force = pos.sub(moverPos);
  float distance = force.length();
  distance = constrain(distance,1,5);
  force.normalize();
  float strength = (G * 1 * m.body.m_mass) / (distance * distance);
  force.mulLocal(strength);<span class="callout-bubble">  Remember, it’s mulLocal() for Vec2.</span>
  return force;
}
</pre>
      <aside data-type="sidebar" class="exercise">
         
         <p>Take any example you made previously using a force calculation and bring that force calculation into Box2D.</p>
         <figure class="screenshot">
            <img alt="ch05 exc10" src="../images/chapter05/ch05_exc10.png"/>
            <figcaption> </figcaption>
         </figure>
      </aside>
   </section>
   <section data-type="sect1" id="chapter05_section13">
      <h1>Collision Events</h1>
      <p>Now we’ve seen a survey of what can be done with Box2D. Since this book is not called “The Nature of Box2D,” it’s not my intention to cover every single possible feature of the Box2D engine. But hopefully by looking at the basics of building bodies, shapes, and joints, when it comes time to use an aspect of Box2D that we haven’t covered, the skills we’ve gained here will make that process considerably less painful. There is one more feature of Box2D, however, that I do think is worth covering.<a data-primary="collisions" data-secondary="Box2D and" data-type="indexterm"> </a>
      </p>
      <p>Let’s ask a question you’ve likely been wondering about:</p>
      <p>
         <em>What if I want something to happen when two Box2D bodies collide? I mean, don’t get me wrong—I’m thrilled that Box2D is handling all of the collisions for me. But if it takes care of everything for me, how am I supposed to know when things are happening?</em>
      </p>
      <p>Your first thoughts when considering an event during which two objects collide might be as follows: Well, if I know all the bodies in the system, and I know where they are all located, then I can just start comparing the locations, see which ones are intersecting, and determine that they’ve collided. That’s a nice thought, but hello??!? The whole point of using Box2D is that Box2D will take care of that for us. If we are going to do the geometry to test for intersection ourselves, then all we’re doing is re-implementing Box2D.<a data-primary="ContactListener class (JBox2D)" data-type="indexterm"> </a>
         <a data-primary="interfaces" data-type="indexterm"> </a>
         <a data-primary="JBox2D" data-secondary="ContactListener class" data-type="indexterm"> </a>
      </p>
      <p>Of course, Box2D has thought of this problem before. It’s a pretty common one. After all, if you intend to make a bajillion dollars selling some game called Angry Birds, you better well make something happen when an ill-tempered pigeon smashes into a cardboard box. Box2D alerts you to moments of collision with something called an “interface.” It’s worth learning about interfaces, an advanced feature of object-oriented programming. You can take a look at the <a href="http://download.oracle.com/javase/tutorial/java/concepts/interface.html">Java Interface Tutorial</a> as well as the JBox2D <strong>ContactListener</strong> class. (I have also included an example on the website that demonstrates using the interface directly.)</p>
      <p>If you are using PBox2D, as we are here, you don’t need to implement your own interface. Detecting collision events is done through a callback function. Much like <strong function="">mousePressed()</strong> is triggered when the mouse is pressed, <strong function="">beginContact()</strong> is triggered when two shapes collide.<a data-primary="beginContact() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="collisions" data-secondary="beginContact() function (PBox2D)" data-type="indexterm"> </a>
      </p>
      <pre>
         void mousePressed() {<span class="callout-bubble">The mousePressed event with which we are comfortable.</span>
  println("The mouse was pressed!");
}

void beginContact(Contact cp) {<span class="callout-bubble">What our "beginContact" event looks like.</span>
  println("Something collided in the Box2D World!");
}
</pre>
      <p>Before the above will work, you must first let PBox2D know you intend to listen for collisions. (This allows the library to reduce overhead by default; it won’t bother listening if it doesn’t have to.)</p>
      <pre>
void setup() {
  box2d = new PBox2D(this);
  box2d.createWorld();
  box2d.listenForCollisions();<span class="callout-bubble">  Add this line if you want to listen for collisions.</span>
}
</pre>
      <p>There are four collision event callbacks.<a data-primary="endContact() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="postSolve() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="preSolve() function (PBox2D)" data-type="indexterm"> </a>
      </p>
      <ol>
         <li>
            <p>
               <strong function="">beginContact()</strong> —Triggered whenever two shapes first come into contact with each other.</p>
         </li>
         <li>
            <p>
               <strong function="">endContact()</strong> —Triggered over and over again as long as shapes continue to be in contact.</p>
         </li>
         <li>
            <p>
               <strong function="">preSolve()</strong> —Triggered before Box2D solves the outcome of the collision, i.e. before <strong function="">beginContact()</strong>. It can be used to disable a collision if necessary.</p>
         </li>
         <li>
            <p>
               <strong function="">postSolve()</strong> —Triggered after the outcome of the collision is solved. It allows you to gather information about that “solution” (known as an “impulse”).</p>
         </li>
      </ol>
      <p>The details behind <strong function="">preSolve()</strong> and <strong function="">postSolve()</strong> are beyond the scope of this book; however, we are going to take a close look at <strong function="">beginContact()</strong>, which will cover the majority of conventional cases in which you want to trigger an action when a collision occurs. <strong function="">endContact()</strong> works identically to <strong function="">beginContact()</strong>, the only difference being that it occurs the moment bodies separate.<a data-primary="endContact() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="postSolve() function (PBox2D)" data-type="indexterm"> </a>
         <a data-primary="preSolve() function (PBox2D)" data-type="indexterm"> </a>
      </p>
      <p>
         <strong function="">beginContact()</strong> is written as follows:<a data-primary="Contact objects (PBox2D)" data-type="indexterm"> </a>
      </p>
      <pre>
void beginContact(Contact cp) {

}
</pre>
      <p>Notice that the function above includes an argument of type <strong klass="">Contact</strong>. A <strong klass="">Contact</strong> object includes all the data associated with a collision—the geometry and the forces. Let’s say we have a Processing sketch with <strong klass="">Particle</strong> objects that store a reference to a Box2D body. Here is the process we are going to follow.<a data-primary="Contact objects (PBox2D)" data-type="indexterm"> </a>
      </p>
      <section data-type="sect2" id="_step_1_contact_could_you_tell_me_what_two_things_collided">
         <h2>Step 1: Contact, could you tell me what two things collided?</h2>
         <p>Now, what has collided here? Is it the bodies? The shapes? The fixtures? Box2D detects collisions between shapes; after all, these are the entities that have geometry. However, because shapes are attached to bodies with fixtures, what we really want to ask Box2D is: “Could you tell me which two fixtures collided?”</p>
         <pre>
            Fixture f1 = cp.getFixtureA();<span class="callout-bubble">The contact stores the fixtures as A and B.</span>
Fixture f2 = cp.getFixtureB();

</pre>
      </section>
      <section data-type="sect2" id="_step_2_fixtures_could_you_tell_me_which_body_you_are_attached_to">
         <h2>Step 2: Fixtures, could you tell me which body you are attached to?</h2>
         <pre>
            Body b1 = f1.getBody();<span class="callout-bubble">getBody() gives us the body to which the Fixture is attached.</span>
Body b2 = f2.getBody();

</pre>
      </section>
      <section data-type="sect2" id="_step_3_bodies_could_you_tell_me_which_particles_you_are_associated_with">
         <h2>Step 3: Bodies, could you tell me which Particles you are associated with?</h2>
         <p>OK, this is the harder part. After all, Box2D doesn’t know anything about our code. Sure, it is doing all sorts of stuff to keep track of the relationships between shapes and bodies and joints, but it’s up to us to manage our own objects and their associations with Box2D elements. Luckily for us, Box2D provides a function that allows us to attach our Processing object (a <strong>Particle</strong>) to a Box2D body via the <strong function="">setUserData()</strong> and <strong function="">getUserData()</strong> methods.</p>
         <p>Let’s take a look at the constructor in our <strong>Particle</strong> class where the body is made. We are expanding our body-making procedure by one line of code, noted below.</p>
         <pre>
class Particle {
  Body body;

  Particle(float x, float y, float r) {
    BodyDef bd = new BodyDef();
    bd.position = box2d.coordPixelsToWorld(x, y);
    bd.type = BodyType.DYNAMIC;
    body = box2d.createBody(bd);
    CircleShape cs = new CircleShape();
    cs.m_radius = box2d.scalarPixelsToWorld(r);
    body.createFixture(fd,1);

<span class="callout-bubble">    "this" refers to this Particle object.</span>
            <span class="callout-bubble">    We are telling the Box2D Body to store a</span>
            <span class="callout-bubble">    reference to this Particle that we can</span>
            <span class="callout-bubble">    access later.</span>
            <em class="strong">    body.setUserData(this);  //[bold]</em>  }
</pre>
         <p>Later, in our <strong function="">addContact()</strong> function, once we know the body, we can access the <strong>Particle</strong> object with <strong function="">getUserData()</strong>.</p>
         <figure class="screenshot">
            <img alt="ch05 ex11" src="../images/chapter05/ch05_ex11.png"/>
            <figcaption> </figcaption>
         </figure>
         <div id="example_d1e3602" data-type="example">
            <h5>CollisionListening</h5>
            <pre>
void beginContact(Contact cp) {

  Fixture f1 = cp.getFixtureA();
  Fixture f2 = cp.getFixtureB();

  Body b1 = f1.getBody();
  Body b2 = f2.getBody();

  Particle p1 = (Particle) b1.getUserData();<span class="callout-bubble">  When we pull the “user data” object out of the Body object, we have to remind our program that it is a Particle object.  Box2D doesn’t know this.</span>
  Particle p2 = (Particle) b2.getUserData();



<span class="callout-bubble">  Once we have the particles, we can do anything to them.  Here we</span>
                 p1.change();<span class="callout-bubble">  just call a function that changes their color.</span>
  p2.change();


}
</pre>
         </div>
         
         <p>Now, in many cases, we cannot assume that the objects that collided are all <strong>Particle</strong> objects. We might have a sketch with <strong>Boundary</strong> objects, <strong>Particle</strong> objects, <strong>Box</strong> objects, etc. So often we will have to query the “user data” and find out what kind of object it is before proceeding.</p>
         <pre>
              Object o1 = b1.getUserData();<span class="callout-bubble">  Getting a generic object</span>
  if (o1.getClass() == Particle.class) {<span class="callout-bubble">  Asking that object if it’s a Particle</span>
    Particle p = (Particle) o1;
    p.change();
  }
</pre>
         <p>It should also be noted that due to how Box2D triggers these callbacks, you cannot create or destroy Box2D entities inside of <strong function="">beginContact()</strong>, <strong function="">endContact()</strong>, <strong function="">preSolve()</strong>, or <strong function="">postSolve()</strong>. If you want to do this, you’ll need to set a variable inside an object (something like: <strong function="">markForDeletion = true</strong>), which you check during <strong function="">draw()</strong> and then delete objects.</p>
         <aside data-type="sidebar" class="exercise">
            
            <p>Consider how polymorphism could help in the above case. Build an example in which several classes extend one class and therefore eliminate the need for such testing.</p>
         </aside>
         <aside data-type="sidebar" class="exercise">
            
            <p>Create a simulation in which <strong>Particle</strong> objects disappear when they collide with one another. Use the methodology I just described.</p>
         </aside>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section14">
      <h1>A Brief Interlude—Integration Methods</h1>
      <p>Has the following ever happened to you? You’re at a fancy cocktail party regaling your friends with tall tales of software physics simulations. Someone pipes up: “Enchanting! But what integration method are you using?” “What?!” you think to yourself. “Integration?”<a data-primary="integration" data-type="indexterm"> </a>
      </p>
      <p>Maybe you’ve heard the term before. Along with “differentiation,” it’s one of the two main operations in calculus. Right, calculus. The good news is, we’ve gotten through about 90% of the material in this book related to physics simulation and we haven’t really needed to dive into calculus. But as we’re coming close to finishing this topic, it’s worth taking a moment to examine the calculus behind what we have been doing and how it relates to the methodology in certain physics libraries (like Box2D and the upcoming toxiclibs).<a data-primary="derivatives" data-type="indexterm"> </a>
         <a data-primary="differentiation" data-type="indexterm"> </a>
      </p>
      <p>Let’s begin by answering the question: “What does integration have to do with location, velocity, and acceleration?” Well, first let’s define <strong>
            <em>differentiation</em>
         </strong>, the process of finding a “derivative.” The derivative of a function is a measure of how a function changes over time. Consider location and its derivative. Location is a point in space, while velocity is change in location over time. Therefore, velocity can be described as the “derivative” of location. What is acceleration? The change in velocity over time—i.e. the “derivative” of velocity.<a data-primary="derivatives" data-type="indexterm"> </a>
         <a data-primary="differentiation" data-type="indexterm"> </a>
      </p>
      <p>Now that we understand the derivative (differentiation), we can define the integral (integration) as the inverse of the derivative. In other words, the integral of an object’s velocity over time tells us the object’s new location when that time period ends. Location is the integral of velocity, and velocity is the integral of acceleration. Since our physics simulation is founded upon the process of calculating acceleration based on forces, we need integration to figure out where the object is after a certain period of time (like one frame of animation!)</p>
      <p>So we’ve been doing integration all along! It looks like this:<a data-primary="Euler integration" data-type="indexterm"> </a>
         <a data-primary="Euler" data-secondary="Leonhard" data-type="indexterm"> </a>
         <a data-primary="integration" data-secondary="Euler integration" data-type="indexterm"> </a>
      </p>
      <pre>
velocity.add(acceleration);
location.add(velocity);
</pre>
      <p>The above methodology is known as Euler integration (named for the mathematician Leonhard Euler, pronounced “Oiler”) or the Euler method. It’s essentially the simplest form of integration and very easy to implement in our code (see the two lines above!) However, it is not necessarily the most efficient form, nor is it close to being the most accurate. Why is Euler inaccurate? Let’s think about it this way. When you drive a car down the road pressing the gas pedal with your foot and accelerating, does the car sit in one location at time equals one second, then disappear and suddenly reappear in a new location at time equals two seconds, and do the same thing for three seconds, and four, and five? No, of course not. The car moves continuously down the road. But what’s happening in our Processing sketch? A circle is at one location at frame 0, another at frame 1, another at frame 2. Sure, at thirty frames per second, we’re seeing the illusion of motion. But we only calculate a new location every <strong class="var">N</strong> units of time, whereas the real world is perfectly continuous. This results in some inaccuracies, as shown in the diagram below:<a data-primary="Euler integration" data-type="indexterm"> </a>
         <a data-primary="Euler" data-secondary="Leonhard" data-type="indexterm"> </a>
         <a data-primary="integration" data-secondary="Euler integration" data-type="indexterm"> </a>
      </p>
      <figure id="chapter05_figure13">
         <img alt="Figure 5.13" src="../images/chapter05/ch05_13.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>The “real world” is the curve; Euler simulation is the series of line segments.</p>
      <p>One option to improve on Euler is to use smaller timesteps—instead of once per frame, we could recalculate an object’s location twenty times per frame. But this isn’t practical; our sketch would then run too slowly.<a data-primary="Euler integration" data-secondary="symplectic Euler (Box2D)" data-type="indexterm"> </a>
         <a data-primary="symplectic Euler (Box2D)" data-type="indexterm"> </a>
      </p>
      <p>I still believe that Euler is the best method for learning the basics, and it’s also perfectly adequate for most of the projects we might make in Processing. Anything we lose in efficiency or inaccuracy we make up in ease of use and understandability. For better accuracy, Box2D uses something called <a href="http://en.wikipedia.org/wiki/Symplectic_Euler_method">symplectic Euler or semi-explicit Euler</a>, a slight modification of Euler.</p>
      <p>There is also an integration method called Runge-Kutta (named for German mathematicians C. Runge and M. W. Kutta), which is used in some physics engines.</p>
      <p>A very popular integration method that our next physics library uses is known as “Verlet integration.” A simple way to describe Verlet integration is to think of our typical motion algorithm without velocity. After all, we don’t really need to store the velocity. If we always know where an object was at one point in time and where it is now, we can extrapolate its velocity. Verlet integration does precisely this, though instead of having a variable for velocity, it calculates velocity while the program is running. Verlet integration is particularly well suited for particle systems, especially particle systems with spring connections between the particles. We don’t need to worry about the details because toxiclibs, as we’ll see below, takes care of them for us. However, if you are interested, here is the seminal paper on Verlet physics, from which just about every Verlet computer graphics simulation is derived: <a href="http://www.gamasutra.com/resource_guide/20030121/jacobson_pfv.htm">"Advanced Character Physics"</a>. And of course, you can find out more about Verlet integration from <a href="http://en.wikipedia.org/wiki/Verlet_integration">Wikipedia</a>.<a data-primary="particle systems" data-secondary="Verlet integration and" data-type="indexterm"> </a>
         <a data-primary="Verlet integration" data-type="indexterm"> </a>
      </p>
   </section>
   <section data-type="sect1" id="chapter05_section15">
      <h1>Verlet Physics with toxiclibs</h1>
      <p>From toxiclibs.org:<a data-primary="Processing" data-secondary="toxiclibs and" data-type="indexterm"> </a>
         <a data-primary="Schmidt" data-secondary="Karsten" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-type="indexterm"> </a>
         <a data-primary="Verlet integration" data-secondary="toxiclibs" data-type="indexterm"> </a>
      </p>
      <p>
         <em>“toxiclibs is an independent, open source library collection for computational design tasks with Java &amp; Processing developed by Karsten “toxi” Schmidt (thus far). The classes are purposefully kept fairly generic in order to maximize re-use in different contexts ranging from generative design, animation, interaction/interface design, data visualization to architecture and digital fabrication, use as teaching tool and more.”</em>
      </p>
      <p>In other words, we should thank our lucky stars for toxiclibs. We are only going to focus on a few examples related to Verlet physics, but toxiclibs includes a suite of other wonderful packages that help with audio, color, geometry, and more. In particular, if you are looking to work with form and fabrication in Processing, take a look at the geometry package. Demos can be found at <a href="http://www.openprocessing.org/portal/?userID=4530">Open Processing</a>.</p>
      <p>We should note that toxiclibs was designed specifically for use with Processing. This is great news. The trouble we had with making Box2D work in Processing (multiple coordinate systems, Box2D vs. JBox2D vs. PBox2D) is not an issue here. toxiclibs is a library that you just download, stick in your libraries folder, and use. And the coordinate system that we’ll use for the physics engine is the coordinate system of Processing, so no translating back and forth. In addition, toxiclibs is not limited to a 2D world; all of the physics simulations and functions work in both two and three dimensions. So how do you decide which library you should use? Box2D or toxiclibs? If you fall into one of the following two categories, your decision is a bit easier:<a data-primary="Box2D" data-secondary="toxiclibs vs." data-type="indexterm"> </a>
         <a data-primary="collisions" data-secondary="toxiclibs and" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-secondary="Box2D vs." data-type="indexterm"> </a>
      </p>
      <p>
         <strong>1. My project involves collisions. I have circles, squares, and other strangely shaped objects that knock each other around and bounce off each other.</strong>
      </p>
      <p>In this case, you are going to need Box2D. toxiclibs does not handle collisions.</p>
      <p>
         <strong>2. My project involves lots of particles flying around the screen. Sometimes they attract each other. Sometimes they repel each other. And sometimes they are connected with springs.</strong>
      </p>
      <p>In this case, toxiclibs is likely your best choice. It is simpler to use than Box2D and particularly well suited to connected systems of particles. toxiclibs is also very high performance, due to the speed of the Verlet integration algorithm (not to mention the fact that the program gets to ignore all of the collision geometry).</p>
      <p>Here is a little chart that covers some of the features for each physics library.</p>
      <table>
         <thead>
            <tr>
               <th>Feature</th>
               <th>Box2D</th>
               <th>toxiclibs VerletPhysics</th>
            </tr>
         </thead>
         <tbody>
            <tr>
               <td>
                  <p>Collision geometry</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
               <td>
                  <p>No</p>
               </td>
            </tr>
            <tr>
               <td>
                  <p>3D physics</p>
               </td>
               <td>
                  <p>No</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
            </tr>
            <tr>
               <td>
                  <p>Particle attraction / repulsion forces</p>
               </td>
               <td>
                  <p>No</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
            </tr>
            <tr>
               <td>
                  <p>Spring connections</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
            </tr>
            <tr>
               <td>
                  <p>Other connections: revolute, pulley, gear, prismatic</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
               <td>
                  <p>No</p>
               </td>
            </tr>
            <tr>
               <td>
                  <p>Motors</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
               <td>
                  <p>No</p>
               </td>
            </tr>
            <tr>
               <td>
                  <p>Friction</p>
               </td>
               <td>
                  <p>Yes</p>
               </td>
               <td>
                  <p>No</p>
               </td>
            </tr>
         </tbody>
      </table>
      <section data-type="sect2" id="_getting_toxiclibs">
         <h2>Getting toxiclibs</h2>
         <p>Everything you need to download and install toxiclibs can be found at:<a data-primary="toxiclibs" data-secondary="downloading" data-type="indexterm"> </a>
         </p>
         <p>
            <a href="http://toxiclibs.org/">toxiclibs</a>
         </p>
         <p>When you download the library, you’ll notice that it comes with eight modules (i.e. sub-folders), each a library in its own right. For the examples in this chapter, you will only need “verletphysics” and “toxiclibscore”; however, I recommend you take a look at and consider using all of the modules!</p>
         <p>Once you have the library installed to your <a href="http://wiki.processing.org/w/How_to_Install_a_Contributed_Library">Processing library folder</a>, you are ready to start looking at the following examples.</p>
      </section>
      <section data-type="sect2" id="_core_elements_of_verletphysics">
         <h2>Core Elements of VerletPhysics</h2>
         <p>We spent a lot of time working through the core elements of a Box2D world: world, body, shape, joint. This gives us a head start on understanding toxiclibs, since it follows a similar structure.<a data-primary="VerletPhysics class (toxiclibs)" data-secondary="core elements of" data-type="indexterm"> </a>
         </p>
         <table>
            <thead>
               <tr>
                  <th>Box2D</th>
                  <th>toxiclibs VerletPhysics</th>
               </tr>
            </thead>
            <tbody>
               <tr>
                  <td>
                     <p>World</p>
                  </td>
                  <td>
                     <p>VerletPhysics</p>
                  </td>
               </tr>
               <tr>
                  <td>
                     <p>Body</p>
                  </td>
                  <td>
                     <p>VerletParticle</p>
                  </td>
               </tr>
               <tr>
                  <td>
                     <p>Shape</p>
                  </td>
                  <td>
                     <p>Nothing! toxiclibs does not handle shape geometry</p>
                  </td>
               </tr>
               <tr>
                  <td>
                     <p>Fixture</p>
                  </td>
                  <td>
                     <p>Nothing! toxiclibs does not handle shape geometry</p>
                  </td>
               </tr>
               <tr>
                  <td>
                     <p>Joint</p>
                  </td>
                  <td>
                     <p>VerletSpring</p>
                  </td>
               </tr>
            </tbody>
         </table>
      </section>
      <section data-type="sect2" id="_vectors_with_toxiclibs">
         <h2>Vectors with toxiclibs</h2>
         <p>Here we go again. Remember all that time we spent learning the ins and outs of the <strong klass="">PVector</strong> class? Then remember how when we got to Box2D, we had to translate all those concepts to a Box2D vector class: <strong klass="">Vec2</strong>? Well, it’s time to do it again. toxiclibs also includes its own vector classes, one for two dimensions and one for three: <strong klass="">Vec2D</strong> and <strong klass="">Vec3D</strong>.<a data-primary="Vec2D (toxiclibs type)" data-type="indexterm"> </a>
            <a data-primary="Vec3D (toxiclibs type)" data-type="indexterm"> </a>
         </p>
         <p>Again, toxiclibs vectors are the same conceptually, but we need to learn a bit of new syntax. You can find all of the documentation for these vector classes here:</p>
         <p>
            <a href="http://toxiclibs.org/docs/core/toxi/geom/Vec2D.html">Vec2D</a>
            <br/>
            <a href="http://toxiclibs.org/docs/core/toxi/geom/Vec3D.html">Vec3D</a>
         </p>
         <p>And let’s just review some of the basic vector math operations with <strong klass="">PVector</strong> translated to <strong klass="">Vec2D</strong> (we’re sticking with 2D for simplicity’s sake).<a data-primary="Vec2D (toxiclibs type)" data-secondary="math functions for" data-type="indexterm"> </a>
         </p>
         <table class="code">
            <tbody>
               <tr>
                  <th>PVector</th>
                  <th>Vec2D</th>
               </tr>
               <tr>
                  <td>
                     <pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
a.add(b);

</pre>
                  </td>
                  <td>
                     <pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
a.addSelf(b);

</pre>
                  </td>
               </tr>
               <tr>
                  <td>
                     <pre>
PVector a = new PVector(1,-1);
PVector b = new PVector(3,4);
PVector c = PVector.add(a,b);

</pre>
                  </td>
                  <td>
                     <pre>
Vec2D a = new Vec2D(1,-1);
Vec2D b = new Vec2D(3,4);
Vec2D c = a.add(b);

</pre>
                  </td>
               </tr>
               <tr>
                  <td>
                     <pre>
PVector a = new PVector(1,-1);
float m = a.mag();
a.normalize();

</pre>
                  </td>
                  <td>
                     <pre>
Vec2D a = new Vec2D(1,-1);
float m = a.magnitude();
a.normalize();

</pre>
                  </td>
               </tr>
            </tbody>
         </table>
      </section>
      <section data-type="sect2" id="_building_the_toxiclibs_physics_world">
         <h2>Building the toxiclibs physics world</h2>
         <p>The first thing we need to do to create a toxiclibs physics world in our examples is import the library itself.</p>
         <pre>
            import toxi.physics2d.*;<span class="callout-bubble">Importing the libraries</span>
import toxi.physics2d.behaviors.*;
import toxi.geom.*;

</pre>
         <p>Then we’ll need a reference to our physics world, a <strong klass="">VerletPhysics</strong> or <strong klass="">VerletPhysics2D</strong> object (depending on whether we are working in two or three dimensions). The examples in this chapter will operate in 2D only for simplicity, but they could easily be extended into 3D (and 3D versions are available with the chapter download).<a data-primary="toxiclibs" data-secondary="VerletPhysics class" data-type="indexterm"> </a>
            <a data-primary="toxiclibs" data-secondary="VerletPhysics2D class" data-type="indexterm"> </a>
            <a data-primary="VerletPhysics class (toxiclibs)" data-type="indexterm"> </a>
            <a data-primary="VerletPhysics2D class (toxiclibs)" data-type="indexterm"> </a>
         </p>
         <pre>
VerletPhysics2D physics;

void setup() {
  physics=new VerletPhysics2D();<span class="callout-bubble">  Creating a toxiclibs Verlet physics world</span>
</pre>
         <p>Once you have your <strong klass="">VerletPhysics</strong> object, you can set some global properties for your world. For example, if you want it to have hard boundaries past which objects cannot travel, you can set its limits:<a data-primary="gravity" data-secondary="GravityBehavior (toxiclibs)" data-type="indexterm"> </a>
            <a data-primary="GravityBehavior class (toxiclibs)" data-type="indexterm"> </a>
         </p>
         <pre>
  physics.setWorldBounds(new Rect(0,0,width,height));
</pre>
         <p>In addition, you can add gravity to the physics world with a <strong>GravityBehavior</strong> object. A gravity behavior requires a vector—how strong and in what direction is the gravity?</p>
         <pre>
  physics.addBehavior(new GravityBehavior(new Vec2D(0,0.5)));
}
</pre>
         <p>Finally, in order to calculate the physics of the world and move the objects in the world, we have to call <strong function="">update()</strong>. Typically this would happen once per frame in <strong function="">draw()</strong>.<a data-primary="update() function (toxiclibs)" data-type="indexterm"> </a>
         </p>
         <pre>
void draw() {
  physics.update();<span class="callout-bubble">  This is the same as Box2D’s “step()” function</span>
}
</pre>
      </section>
   </section>
   <section data-type="sect1" id="chapter05_section16">
      <h1>Particles and Springs in toxiclibs</h1>
      <p>In the Box2D examples, we saw how we can create our own class (called, say, <strong klass="">Particle</strong>) and include a reference to a Box2D body.<a data-primary="particles" data-secondary="toxiclibs implementation of" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-secondary="particles" data-tertiary="implementing in" data-type="indexterm"> </a>
      </p>
      <pre>
class Particle {
  Body body;
</pre>
      <p>This technique is somewhat redundant since Box2D itself keeps track of all of the bodies in its world. However, it allows us to manage which body is which (and therefore how each body is drawn) without having to rely on iterating through Box2D’s internal lists.<a data-primary="particles" data-secondary="VerletParticle2D object (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="VerletParticle2D object (toxiclibs)" data-type="indexterm"> </a>
      </p>
      <p>Let’s look at how we might take the same approach with the class <strong klass="">VerletParticle2D</strong> in toxiclibs. We want to make our own <strong klass="">Particle</strong> class so that we can draw our particles a certain way and include any custom properties. We’d probably write our code as follows:<a data-primary="particles" data-secondary="VerletParticle2D object (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="VerletParticle2D object (toxiclibs)" data-type="indexterm"> </a>
      </p>
      <pre>
class Particle {
  VerletParticle2D p;<span class="callout-bubble">  Our Particle has a reference to a VerletParticle.</span>

  Particle(Vec2D pos) {
    p = new VerletParticle2D(pos);<span class="callout-bubble">    A VerletParticle needs an initial location (an x and y).</span>
  }

  void display() {
    fill(0,150);
    stroke(0);
<span class="callout-bubble">    When it comes time to draw the Particle, we ask the</span>
             ellipse(p.x,p.y,16,16);<span class="callout-bubble">    VerletParticle for its x and y coordinates.</span>
  }
}
</pre>
      <p>Looking at the above, we should first be thrilled to notice that drawing the particle is as simple as grabbing the <em>x</em> and <em>y</em> and using them. No awkward conversions between coordinate systems here since toxiclibs is designed to think in pixels. Second, you might notice that this <strong>Particle</strong> class’s sole purpose is to store a reference to a <strong>VerletParticle2D</strong> object. This hints at something. Remember our discussion of inheritance back in Chapter 4: Particle Systems? What is a <strong>Particle</strong> object other than an “augmented” <strong>VerletParticle</strong>? Why bother making a Verlet particle inside a particle when we could simply <strong>extend VerletParticle</strong>?</p>
      <pre>
class Particle extends VerletParticle2D {

  Particle(Vec2D loc) {
    super(loc);<span class="callout-bubble">    Calling super() so that the object is initialized properly</span>
  }

  void display() {<span class="callout-bubble">  We want this to be just like a VerletParticle, only with a display() method.</span>
    fill(175);
    stroke(0);
    ellipse(x,y,16,16);<span class="callout-bubble">    We’ve inherited x and y from VerletParticle!</span>
  }
}
</pre>
      <p>Remember our multi-step process with the Box2D examples? We had to ask the body for its location, then convert that location to pixels, then use that location in a drawing function. Now, because we have inherited everything from the <strong klass="">VerletParticle</strong> class, our only step is to draw the shape at <strong class="var">x</strong> and <strong class="var">y</strong>!<a data-primary="Vec2D (toxiclibs type)" data-secondary="VerletParticle2D class and" data-type="indexterm"> </a>
      </p>
      <p>Incidentally, it’s interesting to note that the <strong klass="">VerletParticle2D</strong> class is a subclass of <strong klass="">Vec2D</strong>. So in addition to inheriting everything from <strong klass="">VerletParticle2D</strong>, our <strong klass="">Particle</strong> class actually has all of the <strong klass="">Vec2D</strong> functions available as well.<a data-primary="Vec2D (toxiclibs type)" data-secondary="VerletParticle2D class and" data-type="indexterm"> </a>
      </p>
      <p>We can now create particles anywhere within our sketch.<a data-primary="addParticle() function (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="particle systems" data-secondary="addParticle() function (toxiclibs)" data-type="indexterm"> </a>
      </p>
      <pre>
  Particle p1 = new Particle(new Vec2D(100,20));
  Particle p2 = new Particle(new Vec2D(100,180));
</pre>
      <p>Just making a particle isn’t enough, however. We have to make sure we tell our physics world about them with the <strong function="">addParticle()</strong> function.<a data-primary="addParticle() function (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="particle systems" data-secondary="addParticle() function (toxiclibs)" data-type="indexterm"> </a>
      </p>
      <pre>
  physics.addParticle(p1);
  physics.addParticle(p2);
</pre>
      <p>If you look at the toxiclibs documentation, you’ll see that the <strong function="">addParticle()</strong> expects a <strong>VerletParticle2D</strong> object.</p>
      <p>
         <strong function="">addParticle(VerletParticle2D particle)</strong>
      </p>
      <p>And how can we then pass into the function our own <strong klass="">Particle</strong> object? Remember that other tenet of object-oriented programming—polymorphism? Here, because our <strong klass="">Particle</strong> class <strong klass="">extends VerletParticle2D</strong>, we can choose to treat our particle in two different ways—as a <strong klass="">Particle</strong> or as a <strong klass="">VerletParticle2D</strong>. This is an incredibly powerful feature of object-oriented programming. If we build our custom classes based on classes from toxiclibs, we can use our objects in conjunction with all of the functions toxiclibs has to offer.<a data-primary="springs" data-secondary="toxiclibs and" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-secondary="springs" data-type="indexterm"> </a>
      </p>
      <p>In addition to the <strong>VerletParticle</strong> class, toxiclibs has a set of classes that allow you to connect particles with spring forces. There are three types of springs in toxiclibs:</p>
      <ul>
         <li>
            <p>
               <strong>VerletSpring</strong>: This class creates a springy connection between two particles in space. A spring’s properties can be configured in such a way as to create a stiff stick-like connection or a highly elastic stretchy connection. A particle can also be locked so that only one end of the spring can move.</p>
         </li>
         <li>
            <p>
               <strong>VerletConstrainedSpring</strong>: A <strong>VerletConstrainedSpring</strong> object is a spring whose maximum distance can be limited. This can help the whole spring system achieve better stability.</p>
         </li>
         <li>
            <p>
               <strong>VerletMinDistanceSpring</strong>: A <strong>VerletMinDistanceSpring</strong> object is a spring that only enforces its rest length if the current distance is less than its rest length. This is handy if you want to ensure objects are at least a certain distance from each other, but don’t care if the distance is bigger than the enforced minimum.</p>
         </li>
      </ul>
      <p>The inheritance and polymorphism technique we employed in the previous section also proves to be useful when creating springs. A spring expects two particles when it is created. And again, because our <strong klass="">Particle</strong> class <strong klass="">extends VerletParticle</strong>, a <strong klass="">VerletSpring</strong> object will accept our <strong klass="">Particle</strong> objects passed into the constructor. Let’s take a look at some example code that assumes the existence of our two previous particles <strong class="var">p1</strong> and <strong class="var">p2</strong> and creates a connection between them with a given rest length and strength.<a data-primary="springs" data-secondary="VerletConstrainedSpring class (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="springs" data-secondary="VerletMinDistanceSpring class (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="springs" data-secondary="VerletSpring class (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="VerletConstrainedSpring class (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="VerletMinDistanceSpring class (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="VerletSpring class (toxiclibs)" data-type="indexterm"> </a>
      </p>
      <pre>
         float len = 80;<span class="callout-bubble">What is the rest length of the spring?</span>
float strength = 0.01;<span class="callout-bubble">How strong is the spring?</span>
VerletSpring2D spring=new VerletSpring2D(p1,p2,len,strength);
</pre>
      <p>Just as with particles, in order for the connection to actually be part of the physics world, we need to explicitly add it.</p>
      <pre>
physics.addSpring(spring);
</pre>
   </section>
   <section data-type="sect1" id="chapter05_section17">
      <h1>Putting It All Together: A Simple Interactive Spring</h1>
      <p>One thing we saw with Box2D is that the physics simulation broke down when we overrode it and manually set the location of a body. With toxiclibs, we don’t have this problem. If we want to move the location of a particle, we can simply set its <em>x</em> and <em>y</em> location manually. However, before we do so, it’s generally a good idea to call the <strong function="">lock()</strong> function.<a data-primary="lock() function (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="springs" data-secondary="lock() function (toxiclibs)" data-type="indexterm"> </a>
      </p>
      <p>
         <strong function="">lock()</strong> is typically used to lock a particle in place and is identical to setting a Box2D body’s density to 0. However, here we are going to show how to lock a particle temporarily, move it, and then unlock it so that it continues to move according to the physics simulation.  Let’s say you want to move a given particle whenever you click the mouse.</p>
      <pre>
  if (mousePressed) {
    p2.lock();<span class="callout-bubble">    First lock the particle, then set the x and y, then unlock() it.</span>
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();

  }
</pre>
      <p>And now we’re ready to put all of these elements together in a simple example that connects two particles with a spring. One particle is locked in place, and the other can be moved by dragging the mouse. Note that this example is virtually identical to <a href="#chapter03_example11">Example 3.11</a>.</p>
      <figure class="screenshot">
         <img alt="ch05 ex12" src="../images/chapter05/ch05_ex12.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e4728" data-type="example">
         <h5>Simple Spring with toxiclibs</h5>
         <pre>
import toxi.physics2d.*;
import toxi.physics2d.behaviors.*;
import toxi.geom.*;

VerletPhysics2D physics;
Particle p1;
Particle p2;

void setup() {
  size(640,360);

  physics=new VerletPhysics2D();<span class="callout-bubble">  Creating a physics world</span>
  physics.addBehavior(new GravityBehavior2D(new Vec2D(0,0.5)));
  physics.setWorldBounds(new Rect(0,0,width,height));

  p1 = new Particle(new Vec2D(100,20));<span class="callout-bubble">  Creating two Particles</span>
  p2 = new Particle(new Vec2D(100,180));
  p1.lock();<span class="callout-bubble">  Locking Particle 1 in place</span>

  VerletSpring2D spring=new VerletSpring2D(p1,p2,80,0.01);<span class="callout-bubble">  Creating one Spring</span>

  physics.addParticle(p1);<span class="callout-bubble">  Must add everything to the world</span>
  physics.addParticle(p2);
  physics.addSpring(spring);
}

void draw() {
  physics.update();<span class="callout-bubble">  Must update the physics</span>

  background(255);

  line(p1.x,p1.y,p2.x,p2.y);<span class="callout-bubble">  Drawing everything</span>
  p1.display();
  p2.display();

  if (mousePressed) {
    p2.lock();<span class="callout-bubble">    Moving a Particle according to the mouse</span>
    p2.x = mouseX;
    p2.y = mouseY;
    p2.unlock();

  }
}

class Particle extends VerletParticle2D {<span class="callout-bubble">How cute is our simple Particle class?!</span>

  Particle(Vec2D loc) {
    super(loc);
  }

  void display() {
    fill(175);
    stroke(0);
    ellipse(x,y,16,16);
  }
}

</pre>
      </div>
      
   </section>
   <section data-type="sect1" id="chapter05_section18">
      <h1>Connected Systems, Part I: String</h1>
      <p>The above example, two particles connected with a single spring, is the core building block for what toxiclibs’ physics is particularly well suited for: soft body simulations. For example, a string can be simulated by connecting a line of particles with springs. A blanket can be simulated by connecting a grid of particles with springs. And a cute, cuddly, squishy cartoon character can be simulated by a custom layout of particles connected with springs.<a data-primary="connected systems" data-secondary="strings" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-secondary="connected systems" data-type="indexterm"> </a>
      </p>
      <figure id="chapter05_figure14">
         <img alt="Figure 5.14" src="../images/chapter05/ch05_14.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>Let’s begin by simulating a “soft pendulum”—a bob hanging from a string, instead of a rigid arm like we had in <a href="#chapter03_example10">Chapter 3, Example 10</a>. Let’s use the "string" in Figure 5.14 above as our model.</p>
      <p>First, we’ll need a list of particles (let’s use the same <strong>Particle</strong> class we built in the previous example).</p>
      <pre>
ArrayList&lt;Particle&gt; particles = new ArrayList&lt;Particle&gt;();
</pre>
      <p>Now, let’s say we want to have 20 particles, all spaced 10 pixels apart.</p>
      <figure id="chapter05_figure15">
         <img alt="Figure 5.15" src="../images/chapter05/ch05_15.png"/>
         <figcaption> </figcaption>
      </figure>
      <pre>
float len = 10;
float numParticles = 20;
</pre>
      <p>We can loop from <strong class="var">i</strong> equals 0 all the way up to 20, with each particle’s <em>y</em> location set to <strong class="var">i <code>*</code> 10</strong> so that the first particle is at <em>(0,10)</em>, the second at <em>(0,20)</em>, the third at <em>(0,30)</em>, etc.</p>
      <pre>
for(int i=0; i &lt; numPoints; i++) {
  Particle particle=new Particle(i*len,10);<span class="callout-bubble">  Spacing them out along the x-axis</span>
  physics.addParticle(particle);<span class="callout-bubble">  Add the particle to the physics world.</span>
  particles.add(particle);<span class="callout-bubble">  Add the particle to our list.</span>
}
</pre>
      <p>Even though it’s a bit redundant, we’re going to add the particle to both the toxiclibs physics world and to our own list. In case we eventually have multiple strings, this will allow us to know which particles are connected to which strings.</p>
      <p>Now for the fun part: It’s time to connect all the particles. Particle 1 will be connected to particle 0, particle 2 to particle 1, 3 to 2, 4 to 3, etc.</p>
      <figure id="chapter05_figure16">
         <img alt="Figure 5.16" src="../images/chapter05/ch05_16.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>In other words, particle <strong class="var">i</strong> needs to be connected to particle <strong class="var">i-1</strong> (except for when <strong class="var">i</strong> equals zero).<a data-primary="strings" data-secondary="hanging from fixed points" data-type="indexterm"> </a>
      </p>
      <pre>
if (i != 0) {
  Particle previous = particles.get(i-1);<span class="callout-bubble">  First we need a reference to the previous particle.</span>

  VerletSpring2D spring = new VerletSpring2D(particle,previous,len,strength);<span class="callout-bubble">  Then we make a spring connection between the particle and the previous particle with a rest length and strength (both floats).</span>




  physics.addSpring(spring);<span class="callout-bubble">  We must not forget to add the spring to the physics world.</span>
}
</pre>
      <p>Now, what if we want the string to hang from a fixed point? We can lock one of the particles—the first, the last, the middle one, etc. Here’s how we would access the first particle (in the <strong klass="">ArrayList</strong>) and lock it.<a data-primary="strings" data-secondary="hanging from fixed points" data-type="indexterm"> </a>
      </p>
      <pre>
Particle head=particles.get(0);
head.lock();
</pre>
      <p>And if we want to draw all the particles as being connected with a line, along with a circle for the last particle, we can use <strong function="">beginShape()</strong>, <strong function="">endShape()</strong>, and <strong function="">vertex()</strong>, accessing the particle locations from our <strong>ArrayList</strong>.</p>
      <figure class="screenshot">
         <img alt="ch05 ex13" src="../images/chapter05/ch05_ex13.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e4933" data-type="example">
         <h5>Soft swinging pendulum</h5>
         <pre>
stroke(0);
noFill();
beginShape();
for (Particle p : particles) {
  vertex(p.x,p.y);<span class="callout-bubble">  Each particle is one point in the line.</span>
}
endShape();
Particle tail = particles.get(numPoints-1);
tail.display();<span class="callout-bubble">This draws the last particle as a circle.</span>
</pre>
      </div>
      
      <p>The full code available with the chapter download also demonstrates how to drag the tail particle with the mouse.</p>
      <aside data-type="sidebar" class="exercise">
         
         <p>Create a hanging cloth simulation using the technique above, but connect all the particles with a grid as demonstrated in the screenshot below.</p>
         <figure class="screenshot">
            <img alt="ch05 exc13" src="../images/chapter05/ch05_exc13.png"/>
            <figcaption> </figcaption>
         </figure>
      </aside>
   </section>
   <section data-type="sect1" id="chapter05_section19">
      <h1>Connected Systems, Part II: Force-Directed Graph</h1>
      <p>Have you ever encountered the following scenario?<a data-primary="connected systems" data-secondary="force-directed graphs" data-type="indexterm"> </a>
         <a data-primary="force-directed graphs" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-secondary="force-directed graphs" data-type="indexterm"> </a>
      </p>
      <p>“I have a whole bunch of stuff I want to draw on the screen and I want all that stuff to be spaced out evenly in a nice, neat, organized manner. Otherwise I have trouble sleeping at night.”</p>
      <p>This is not an uncommon problem in computational design. One solution is typically referred to as a “force-directed graph.” A force-directed graph is a visualization of elements—let’s call them “nodes”—in which the positions of those nodes are not manually assigned. Rather, the nodes arrange themselves according to a set of forces. While any forces can be used, a typical example involves spring forces. And so toxiclibs is perfect for this scenario.</p>
      <figure class="three-col">
         <img alt="ch05 ex14" src="../images/chapter05/ch05_ex14.png"/>
         <figcaption> </figcaption>
      </figure>
      <figure class="three-col">
         <img alt="ch05 ex15" src="../images/chapter05/ch05_ex15.png"/>
         <figcaption> </figcaption>
      </figure>
      <figure class="three-col">
         <img alt="ch05 ex16" src="../images/chapter05/ch05_ex16.png"/>
         <figcaption> </figcaption>
      </figure>
      <p>How do we implement the above?</p>
      <p>First, we’ll need a <strong>Node</strong> class. This is the easy part; it can <strong>extend VerletParticle2D</strong>. Really, this is just what we did before, only we’re calling it <strong>Node</strong> now instead of <strong>Particle</strong>.</p>
      <pre>
class Node extends VerletParticle2D {
  Node(Vec2D pos) {
    super(pos);
  }

  void display() {
    fill(0,150);
    stroke(0);
    ellipse(x,y,16,16);
  }
}
</pre>
      <p>Next we can write a class called <strong>Cluster</strong>, which will describe a list of nodes.</p>
      <pre>
class Cluster {

  ArrayList&lt;Node&gt; nodes;

<span class="callout-bubble">  We’ll use this variable for the rest</span>
           float diameter;<span class="callout-bubble">  length between all the nodes.</span>

  Cluster(int n, float d, Vec2D center) {
    nodes = new ArrayList&lt;Node&gt;();
    diameter = d;

    for (int i = 0; i &lt; n; i++) {
<span class="callout-bubble">      Here’s a funny little detail.  We’re going to have a problem</span>
         <span class="callout-bubble">      if all the Node objects start in exactly the same location.</span>
         <span class="callout-bubble">      So we add a random vector to the center location so that each</span>
               nodes.add(new Node(center.add(Vec2D.randomVector())));<span class="callout-bubble">      Node is slightly offset.</span>



    }
  }
</pre>
      <p>Let’s assume we added a <strong function="">display()</strong> function to draw all the nodes in the cluster and created a <strong>Cluster</strong> object in <strong function="">setup()</strong> and displayed it in <strong function="">draw()</strong>. If we ran the sketch as is, nothing would happen. Why? Because we forgot the whole force-directed graph part! We need to connect every single node to every other node with a force. But what exactly do we mean by that? Let’s assume we have four <strong>Node</strong> objects: 0, 1, 2 and 3. Here are our connections:</p>
      <p>
         <strong mono="">0 connected to 1<br/>
0 connected to 2<br/>
0 connected to 3<br/>
1 connected to 2<br/>
1 connected to 3<br/>
2 connected to 3</strong>
      </p>
      <p>Notice two important details about our connection list.</p>
      <ul>
         <li>
            <p>
               <strong>
                  <em>No node is connected to itself.</em>
               </strong> We don’t have 0 connected to 0 or 1 connected to 1.</p>
         </li>
         <li>
            <p>
               <strong>
                  <em>We don’t need to repeat connections in reverse.</em>
               </strong> In other words, if we’ve already said 0 is connected to 1, we don’t need to say 1 is connected to 0 because, well, it already is!</p>
         </li>
      </ul>
      <p>So how do we write code to make these connections for <em>N</em> number of nodes?</p>
      <p>Look at the left column. It reads: 000 11 2. So we know we need to access each node in the list from 0 to <em>N</em>-1.</p>
      <pre>
    for (int i = 0; i &lt; nodes.size()-1; i++) {
      VerletParticle2D ni = nodes.get(i);
</pre>
      <p>Now, we know we need to connect node 0 to nodes 1,2,3. For node 1: 2,3. For node 2: 3. So for every node i, we must loop from i+1 until the end of the list.</p>
      <pre>
         <span class="callout-bubble">      Look how we start j at i + 1.</span>
         <em class="strong">      for (int j = i+1; j &lt; nodes.size(); j++) { //[bold]</em>        VerletParticle2D nj = nodes.get(j);
</pre>
      <p>With every two <strong>Node</strong>
         <code>s</code> we find, all we have to do then is make a spring.</p>
      <pre>
                 physics.addSpring(new VerletSpring2D(ni,nj,diameter,0.01));<span class="callout-bubble">        The Spring connects Nodes “ni” and “nj”.</span>
      }
    }
</pre>
      <p>Assuming those connections are made in the <strong>Cluster</strong> constructor, we can now create a cluster in our main tab and see the results!</p>
      <figure class="screenshot">
         <img alt="ch05 ex17" src="../images/chapter05/ch05_ex17.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e5190" data-type="example">
         <h5>Cluster</h5>
         <pre>
import toxi.geom.*;
import toxi.physics2d.*;

VerletPhysics2D physics;
Cluster cluster;

void setup() {
  size(300,300);
  physics=new VerletPhysics2D();
  cluster = new Cluster(8,100,new Vec2D(width/2,height/2));<span class="callout-bubble">  Make a cluster.</span>
}

void draw() {
  physics.update();
  background(255);
  cluster.display();<span class="callout-bubble">  Draw the cluster.</span>
}
</pre>
      </div>
      
      <aside data-type="sidebar" class="exercise">
         
         <p>Use the <strong>Cluster</strong> structure as a skeleton for a cute, cuddly, squishy creature (à la “Nokia Friends”). Add gravity and also allow the creature to be dragged with the mouse.</p>
      </aside>
      <aside data-type="sidebar" class="exercise">
         
         <p>Expand the force-directed graph to have more than one <strong>Cluster</strong> object. Use a <strong>VerletMinDistanceSpring2D</strong> object to connect cluster to cluster.</p>
         <figure class="screenshot">
            <img alt="ch05 exc15" src="../images/chapter05/ch05_exc15.png"/>
            <figcaption> </figcaption>
         </figure>
      </aside>
   </section>
   <section data-type="sect1" id="chapter05_section20">
      <h1>Attraction and Repulsion Behaviors</h1>
      <p>When we looked at adding an attraction force to Box2D, we found that the Box2D <strong>Body</strong> class included an <strong function="">applyForce()</strong> function. All we needed to do was calculate the attraction force (Force = G * mass1 * mass2 / distance squared) as a vector and apply it to the body. toxiclibs <strong>VerletParticle</strong> class also includes a function called <strong function="">addForce()</strong> that we can use to apply any calculated force to a particle.</p>
      <p>However, toxiclibs also takes this idea one step further by allowing us to attach some common forces (let’s call them “behaviors”) to particles, calculating them and applying them for us! For example, if we attach an <strong klass="">AttractionBehavior</strong> object to a particle, then all other particles in the physics world will be attracted to that particle.<a data-primary="AttractionBehavior class (toxiclibs)" data-type="indexterm"> </a>
         <a data-primary="toxiclibs" data-secondary="AttractionBehavior class" data-type="indexterm"> </a>
      </p>
      <p>Let’s say we have a <strong>Particle</strong> class (that <strong>extends VerletParticle</strong>).</p>
      <pre>
Particle p = new Particle(new Vec2D(200,200));
</pre>
      <p>Once we’ve made a <strong>Particle</strong> object, we can create an <strong>AttractionBehavior</strong> object associated with that particle.</p>
      <pre>
float distance = 20;
float strength = 0.1;
AttractionBehavior behavior = new AttractionBehavior(p, distance, strength);
</pre>
      <p>Notice how the behavior is created with two parameters—<strong class="var">distance</strong> and <strong class="var">strength</strong>. The distance specifies the range within which the behavior will be applied. For example, in the above scenario, only other particles within twenty pixels will feel the attraction force. The strength, of course, specifies how strong the force is.</p>
      <p>Finally, in order for the force to be activated, the behavior needs to be added to the physics world.</p>
      <pre>
physics.addBehavior(behavior);
</pre>
      <p>This means everything that lives in the physics simulation will always be attracted to that particle, as long as it is within the distance threshold.</p>
      <p>Even though toxiclibs does not handle collisions, you can create a collision-like effect by adding a repulsive behavior to each and every particle (so that every particle repels every other particle). Let’s look at how we might modify our <strong>Particle</strong> class to do this.</p>
      <pre>
class Particle extends VerletParticle2D {

  float r;<span class="callout-bubble">  We’ve added a radius to every Particle.</span>

  Particle (Vec2D loc) {
    super(loc);
    r = 4;
<span class="callout-bubble">    Every time a Particle is made, an AttractionBehavior is</span>
         <span class="callout-bubble">    generated and added to the physics world.</span>
         <span class="callout-bubble">    Note that when the strength</span>
             physics.addBehavior(new AttractionBehavior(this, r*4, -1));<span class="callout-bubble">    is negative, it’s a repulsive force!</span>
  }

  void display () {
    fill (255);
    stroke (255);
    ellipse (x, y, r*2, r*2);
  }
}
</pre>
      <p>We could now recreate our attraction example by having a single <strong>Attractor</strong> object that exerts an attraction behavior over the entire window.</p>
      <figure class="screenshot">
         <img alt="ch05 ex18" src="../images/chapter05/ch05_ex18.png"/>
         <figcaption> </figcaption>
      </figure>
      <div id="example_d1e5355" data-type="example">
         <h5>Attraction/Repulsion</h5>
         <pre>
class Attractor extends VerletParticle2D {

  float r;

  Attractor (Vec2D loc) {
    super (loc);
    r = 24;
<span class="callout-bubble">    The AttractionBehavior “distance” equals</span>
                physics.addBehavior(new AttractionBehavior(this, width, 0.1));<span class="callout-bubble">    the width so that it covers the entire window.</span>
  }

  void display () {
    fill(0);
    ellipse (x, y, r*2, r*2);
  }
}
</pre>
      </div>
      
      <aside data-type="sidebar" class="exercise">
         
         <p>Create an object that both attracts and repels. What if it attracts any particle that is far away but repels those particles at a short distance?</p>
      </aside>
      <aside data-type="sidebar" class="exercise">
         
         <p>Use <strong>AttractionBehavior</strong> in conjunction with spring forces.</p>
      </aside>
      <div data-type="tip">
         <h1>The Ecosystem Project</h1>
         <p>Step 5 Exercise:</p>
         <p>Take your system of creatures from Step 4 and use a physics engine to drive their motion and behaviors. Some possibilities:</p>
         <ul>
            <li>
               <p>Use Box2D to allow collisions between creatures. Consider triggering events when creatures collide.</p>
            </li>
            <li>
               <p>Use Box2D to augment the design of your creatures. Build a skeleton with distance joints or make appendages with revolute joints.</p>
            </li>
            <li>
               <p>Use toxiclibs to augment the design of your creature. Use a chain of toxiclibs particles for tentacles or a mesh of springs as a skeleton.</p>
            </li>
            <li>
               <p>Use toxiclibs to add attraction and repulsion behaviors to your creatures.</p>
            </li>
            <li>
               <p>Use spring (or joint) connections between objects to control their interactions. Create and delete these springs on the fly. Consider making these connections visible or invisible to the viewer.</p>
            </li>
         </ul>
      </div>
   </section>
</section>
